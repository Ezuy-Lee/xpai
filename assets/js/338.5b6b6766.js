(window.webpackJsonp=window.webpackJsonp||[]).push([[338],{765:function(e,s,a){"use strict";a.r(s);var t=a(15),r=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"redis为什么查询快-效率高"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis为什么查询快-效率高"}},[e._v("#")]),e._v(" redis为什么查询快，效率高？")]),e._v(" "),a("h3",{attrs:{id:"_100000-qps-每秒内查询次数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_100000-qps-每秒内查询次数"}},[e._v("#")]),e._v(" 100000+QPS（每秒内查询次数）")]),e._v(" "),a("p",[e._v("1、完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高\n2、数据结构简单，对数据操作也简单\n3、采用单线程，单线程也能处理高并发请求，想多核也可启动多实例\n4、使用多路I/O复用模型，非阻塞IO")]),e._v(" "),a("h3",{attrs:{id:"多路i-o复用模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多路i-o复用模型"}},[e._v("#")]),e._v(" 多路I/O复用模型")]),e._v(" "),a("p",[e._v("Redis采用的I/O多路复用函数：epoll/kqueue/evport/select")]),e._v(" "),a("p",[e._v("1、因地制宜\n2、优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现\n3、以时间复杂度为O(n)的select作为保底\n4、基于react设计模式监听I/O事件")]),e._v(" "),a("p",[e._v("hyperLogLog ： 用于计数    Geo：用于储存地理位置信息")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("scan cursor [MATCH pattern][COUNT count]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("1、基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程\n2、以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历\n3、不保证每次执行都返回某个给定数量的元素，支持模糊查询\n4、一次返回的数量不可控，只能是大概率符合count参数")]),e._v(" "),a("h2",{attrs:{id:"redis如何实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis如何实现分布式锁"}},[e._v("#")]),e._v(" redis如何实现分布式锁？")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("SET key value [EX seconds][PX milliseconds][NX|XX]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("1、EX second:设置键的过期时间为second秒\n2、PX millisecond：设置键的过期时间为millisecond毫秒\n3、NX：只在键不存在时，才对键进行设置操作\n4、XX：只在键已经存在时，才对键进行设置操作\n5、SET 操作成功完成时，返回OK，否则返回nil")]),e._v(" "),a("h2",{attrs:{id:"redis做异步队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis做异步队列"}},[e._v("#")]),e._v(" redis做异步队列？")]),e._v(" "),a("p",[e._v("BLPOP key [key...] timeout：阻塞直到队列有消息或者超时")]),e._v(" "),a("p",[e._v("1、缺点：")]),e._v(" "),a("p",[e._v("只能提供一个消费者消费")]),e._v(" "),a("p",[e._v("pub(publish)/sub（subscribe）:主题订阅者模式")]),e._v(" "),a("p",[e._v("1、发送者（pub）发送消息，订阅者（sub）接收消息\n2、订阅者可以订阅任意数量的频道\n缺点：")]),e._v(" "),a("p",[e._v("消息的发布是无状态的，无法保证可达")]),e._v(" "),a("h2",{attrs:{id:"redis持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化"}},[e._v("#")]),e._v(" redis持久化")]),e._v(" "),a("h3",{attrs:{id:"_1、rdb-快照-持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、rdb-快照-持久化"}},[e._v("#")]),e._v(" 1、RDB（快照）持久化")]),e._v(" "),a("p",[e._v("保存某个时间点的全量数据快照")]),e._v(" "),a("p",[e._v("①save：阻塞redis的服务器进程，直到RDB文件被创建完毕\n②BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程")]),e._v(" "),a("p",[e._v("根据redis.conf配置里的SAVE m n 定时触发（用的是BGSAVE）")]),e._v(" "),a("p",[e._v("主从复制时，主节点自动触发\n执行Debug Reload\n执行Shutdown且没有开启AOF持久化")]),e._v(" "),a("p",[e._v("缺点：")]),e._v(" "),a("p",[e._v("①内存数据的全量同步，数据量大会由于I/O而严重影响性能\n②可能会因为Redis挂掉而丢失当前至最新一次快照期间数据")]),e._v(" "),a("h3",{attrs:{id:"_2、aof-append-only-file-持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、aof-append-only-file-持久化"}},[e._v("#")]),e._v(" 2、AOF（Append-Only-File）持久化")]),e._v(" "),a("p",[e._v("保存写状态")]),e._v(" "),a("p",[e._v("①记录下除了查询以外的所有表更数据库状态的指令\n②以append的形式追加保存到AOF文件中（增量）")]),e._v(" "),a("p",[e._v("日志重写解决AOP文件大小不断增大的问题，原理如下")]),e._v(" "),a("p",[e._v("1、调用fork()，创建一个子进程\n2、子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件\n3、主进程持续将新的变动同时写到内存和原来的AOF里\n4、主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动\n5、使用新的AOF文件替换旧的AOF文件")]),e._v(" "),a("h3",{attrs:{id:"rdb-aof混合持久化方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb-aof混合持久化方式"}},[e._v("#")]),e._v(" RDB-AOF混合持久化方式")]),e._v(" "),a("p",[e._v("1、BGSAVE做镜像全量持久化，AOF做增量持久化")]),e._v(" "),a("h4",{attrs:{id:"使用pipeline的好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用pipeline的好处"}},[e._v("#")]),e._v(" 使用Pipeline的好处")]),e._v(" "),a("p",[e._v("1、Pipeline和Linux的管道类似\n2、redis基于请求/响应模式，单个请求处理需要一一应答\n3、Pipeline批量执行指令，节省多次IO往返的时间\n4、有顺序依赖的指令建议分批发送")]),e._v(" "),a("h2",{attrs:{id:"redis的同步机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis的同步机制"}},[e._v("#")]),e._v(" redis的同步机制")]),e._v(" "),a("h3",{attrs:{id:"主从同步原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从同步原理"}},[e._v("#")]),e._v(" 主从同步原理")]),e._v(" "),a("p",[e._v("1、全同步过程")]),e._v(" "),a("p",[e._v("①Salve发送sync命令到Master\n②Master启动一个后台进程，将Redis中的数据快照保存到文件中\n③Master将保存数据快照期间接收到的写命令缓存起来\n④Master完成写文件操作后，将该文件发送给Salve\n⑤使用新的AOF文件替换掉旧的AOF文件\n⑥Master将这期间收集的增量写命令发送给Salve端")]),e._v(" "),a("p",[e._v("2、增量同步过程")]),e._v(" "),a("p",[e._v("①Master接收到用户的操作指令，判断是否需要传播到Slave\n②将操作记录追加到AOF文件\n③将操作传播到其他Slave ：1、对齐主从库2、往响应缓存写入指令\n④将缓存中的数据发送给Slave")]),e._v(" "),a("h2",{attrs:{id:"redis-sentinel-解决主从同步master宕机后的主从切换问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-sentinel-解决主从同步master宕机后的主从切换问题"}},[e._v("#")]),e._v(" redis sentinel 解决主从同步Master宕机后的主从切换问题？")]),e._v(" "),a("p",[e._v("1、监控：检查主从服务器是否运行正常\n2、提醒：通过API向管理员或者其他应用程序发送故障通知\n3、自动故障迁移：主从切换")]),e._v(" "),a("p",[e._v("流言协议Gossip：在杂乱无章中寻求一致")]),e._v(" "),a("p",[e._v("1、每个节点都随机地与对方通信，最终所有节点的状态达成一致\n2、种子节点定期随机向其他节点发送节点列表以及需要传播的消息\n3、不保证信息一定会传递给所有节点，但是最终会趋于一致")])])}),[],!1,null,null,null);s.default=r.exports}}]);