(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{556:function(e,n,s){"use strict";s.r(n);var t=s(15),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" "),s("strong",[e._v("前言")])]),e._v(" "),s("p",[e._v("上一篇文章Quartz数据库表分析介绍了Quartz默认提供的11张表，本文将具体分析Quartz是如何调度的，是如何通过数据库的方式来现在分布式调度。")]),e._v(" "),s("h2",{attrs:{id:"调度线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调度线程"}},[e._v("#")]),e._v(" "),s("strong",[e._v("调度线程")])]),e._v(" "),s("p",[e._v("Quartz内部提供的调度类是QuartzScheduler，而QuartzScheduler会委托QuartzSchedulerThread去实时调度；当调度完需要去执行job的时候QuartzSchedulerThread并没有直接去执行job，"),s("br"),e._v("\n而是交给ThreadPool去执行job，具体使用什么ThreadPool，初始化多线线程，可以在配置文件中进行配置：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool\norg.quartz.threadPool.threadCount: 10\norg.quartz.threadPool.threadPriority: 5\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("常用的线程池是SimpleThreadPool，这里默认启动了10个线程，在SimpleThreadPool会创建10个WorkerThread，由WorkerThread去执行具体的job；")]),e._v(" "),s("h2",{attrs:{id:"调度分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调度分析"}},[e._v("#")]),e._v(" "),s("strong",[e._v("调度分析")])]),e._v(" "),s("p",[e._v("QuartzSchedulerThread是调度的核心类，具体Quartz是如何实现调度的，可以查看QuartzSchedulerThread核心源码：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('public void run() {\n    boolean lastAcquireFailed = false;\n \n    while (!halted.get()) {\n        try {\n            // check if we\'re supposed to pause...\n            synchronized (sigLock) {\n                while (paused && !halted.get()) {\n                    try {\n                        // wait until togglePause(false) is called...\n                        sigLock.wait(1000L);\n                    } catch (InterruptedException ignore) {\n                    }\n                }\n \n                if (halted.get()) {\n                    break;\n                }\n            }\n \n            int availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();\n            if(availThreadCount > 0) { // will always be true, due to semantics of blockForAvailableThreads...\n \n                List<OperableTrigger> triggers = null;\n \n                long now = System.currentTimeMillis();\n \n                clearSignaledSchedulingChange();\n                try {\n                    triggers = qsRsrcs.getJobStore().acquireNextTriggers(\n                            now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());\n                    lastAcquireFailed = false;\n                    if (log.isDebugEnabled()) \n                        log.debug("batch acquisition of " + (triggers == null ? 0 : triggers.size()) + " triggers");\n                } catch (JobPersistenceException jpe) {\n                    if(!lastAcquireFailed) {\n                        qs.notifySchedulerListenersError(\n                            "An error occurred while scanning for the next triggers to fire.",\n                            jpe);\n                    }\n                    lastAcquireFailed = true;\n                    continue;\n                } catch (RuntimeException e) {\n                    if(!lastAcquireFailed) {\n                        getLog().error("quartzSchedulerThreadLoop: RuntimeException "\n                                +e.getMessage(), e);\n                    }\n                    lastAcquireFailed = true;\n                    continue;\n                }\n \n                if (triggers != null && !triggers.isEmpty()) {\n \n                    now = System.currentTimeMillis();\n                    long triggerTime = triggers.get(0).getNextFireTime().getTime();\n                    long timeUntilTrigger = triggerTime - now;\n                    while(timeUntilTrigger > 2) {\n                        synchronized (sigLock) {\n                            if (halted.get()) {\n                                break;\n                            }\n                            if (!isCandidateNewTimeEarlierWithinReason(triggerTime, false)) {\n                                try {\n                                    // we could have blocked a long while\n                                    // on \'synchronize\', so we must recompute\n                                    now = System.currentTimeMillis();\n                                    timeUntilTrigger = triggerTime - now;\n                                    if(timeUntilTrigger >= 1)\n                                        sigLock.wait(timeUntilTrigger);\n                                } catch (InterruptedException ignore) {\n                                }\n                            }\n                        }\n                        if(releaseIfScheduleChangedSignificantly(triggers, triggerTime)) {\n                            break;\n                        }\n                        now = System.currentTimeMillis();\n                        timeUntilTrigger = triggerTime - now;\n                    }\n \n                    // this happens if releaseIfScheduleChangedSignificantly decided to release triggers\n                    if(triggers.isEmpty())\n                        continue;\n \n                    // set triggers to \'executing\'\n                    List<TriggerFiredResult> bndles = new ArrayList<TriggerFiredResult>();\n \n                    boolean goAhead = true;\n                    synchronized(sigLock) {\n                        goAhead = !halted.get();\n                    }\n                    if(goAhead) {\n                        try {\n                            List<TriggerFiredResult> res = qsRsrcs.getJobStore().triggersFired(triggers);\n                            if(res != null)\n                                bndles = res;\n                        } catch (SchedulerException se) {\n                            qs.notifySchedulerListenersError(\n                                    "An error occurred while firing triggers \'"\n                                            + triggers + "\'", se);\n                            //QTZ-179 : a problem occurred interacting with the triggers from the db\n                            //we release them and loop again\n                            for (int i = 0; i < triggers.size(); i++) {\n                                qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));\n                            }\n                            continue;\n                        }\n \n                    }\n \n                    for (int i = 0; i < bndles.size(); i++) {\n                        TriggerFiredResult result =  bndles.get(i);\n                        TriggerFiredBundle bndle =  result.getTriggerFiredBundle();\n                        Exception exception = result.getException();\n \n                        if (exception instanceof RuntimeException) {\n                            getLog().error("RuntimeException while firing trigger " + triggers.get(i), exception);\n                            qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));\n                            continue;\n                        }\n \n                        // it\'s possible to get \'null\' if the triggers was paused,\n                        // blocked, or other similar occurrences that prevent it being\n                        // fired at this time...  or if the scheduler was shutdown (halted)\n                        if (bndle == null) {\n                            qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));\n                            continue;\n                        }\n \n                        JobRunShell shell = null;\n                        try {\n                            shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);\n                            shell.initialize(qs);\n                        } catch (SchedulerException se) {\n                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);\n                            continue;\n                        }\n \n                        if (qsRsrcs.getThreadPool().runInThread(shell) == false) {\n                            // this case should never happen, as it is indicative of the\n                            // scheduler being shutdown or a bug in the thread pool or\n                            // a thread pool being used concurrently - which the docs\n                            // say not to do...\n                            getLog().error("ThreadPool.runInThread() return false!");\n                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);\n                        }\n \n                    }\n \n                    continue; // while (!halted)\n                }\n            } else { // if(availThreadCount > 0)\n                // should never happen, if threadPool.blockForAvailableThreads() follows contract\n                continue; // while (!halted)\n            }\n \n            long now = System.currentTimeMillis();\n            long waitTime = now + getRandomizedIdleWaitTime();\n            long timeUntilContinue = waitTime - now;\n            synchronized(sigLock) {\n                try {\n                  if(!halted.get()) {\n                    // QTZ-336 A job might have been completed in the mean time and we might have\n                    // missed the scheduled changed signal by not waiting for the notify() yet\n                    // Check that before waiting for too long in case this very job needs to be\n                    // scheduled very soon\n                    if (!isScheduleChanged()) {\n                      sigLock.wait(timeUntilContinue);\n                    }\n                  }\n                } catch (InterruptedException ignore) {\n                }\n            }\n \n        } catch(RuntimeException re) {\n            getLog().error("Runtime error occurred in main trigger firing loop.", re);\n        }\n    } // while (!halted)\n \n    // drop references to scheduler stuff to aid garbage collection...\n    qs = null;\n    qsRsrcs = null;\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br"),s("span",{staticClass:"line-number"},[e._v("54")]),s("br"),s("span",{staticClass:"line-number"},[e._v("55")]),s("br"),s("span",{staticClass:"line-number"},[e._v("56")]),s("br"),s("span",{staticClass:"line-number"},[e._v("57")]),s("br"),s("span",{staticClass:"line-number"},[e._v("58")]),s("br"),s("span",{staticClass:"line-number"},[e._v("59")]),s("br"),s("span",{staticClass:"line-number"},[e._v("60")]),s("br"),s("span",{staticClass:"line-number"},[e._v("61")]),s("br"),s("span",{staticClass:"line-number"},[e._v("62")]),s("br"),s("span",{staticClass:"line-number"},[e._v("63")]),s("br"),s("span",{staticClass:"line-number"},[e._v("64")]),s("br"),s("span",{staticClass:"line-number"},[e._v("65")]),s("br"),s("span",{staticClass:"line-number"},[e._v("66")]),s("br"),s("span",{staticClass:"line-number"},[e._v("67")]),s("br"),s("span",{staticClass:"line-number"},[e._v("68")]),s("br"),s("span",{staticClass:"line-number"},[e._v("69")]),s("br"),s("span",{staticClass:"line-number"},[e._v("70")]),s("br"),s("span",{staticClass:"line-number"},[e._v("71")]),s("br"),s("span",{staticClass:"line-number"},[e._v("72")]),s("br"),s("span",{staticClass:"line-number"},[e._v("73")]),s("br"),s("span",{staticClass:"line-number"},[e._v("74")]),s("br"),s("span",{staticClass:"line-number"},[e._v("75")]),s("br"),s("span",{staticClass:"line-number"},[e._v("76")]),s("br"),s("span",{staticClass:"line-number"},[e._v("77")]),s("br"),s("span",{staticClass:"line-number"},[e._v("78")]),s("br"),s("span",{staticClass:"line-number"},[e._v("79")]),s("br"),s("span",{staticClass:"line-number"},[e._v("80")]),s("br"),s("span",{staticClass:"line-number"},[e._v("81")]),s("br"),s("span",{staticClass:"line-number"},[e._v("82")]),s("br"),s("span",{staticClass:"line-number"},[e._v("83")]),s("br"),s("span",{staticClass:"line-number"},[e._v("84")]),s("br"),s("span",{staticClass:"line-number"},[e._v("85")]),s("br"),s("span",{staticClass:"line-number"},[e._v("86")]),s("br"),s("span",{staticClass:"line-number"},[e._v("87")]),s("br"),s("span",{staticClass:"line-number"},[e._v("88")]),s("br"),s("span",{staticClass:"line-number"},[e._v("89")]),s("br"),s("span",{staticClass:"line-number"},[e._v("90")]),s("br"),s("span",{staticClass:"line-number"},[e._v("91")]),s("br"),s("span",{staticClass:"line-number"},[e._v("92")]),s("br"),s("span",{staticClass:"line-number"},[e._v("93")]),s("br"),s("span",{staticClass:"line-number"},[e._v("94")]),s("br"),s("span",{staticClass:"line-number"},[e._v("95")]),s("br"),s("span",{staticClass:"line-number"},[e._v("96")]),s("br"),s("span",{staticClass:"line-number"},[e._v("97")]),s("br"),s("span",{staticClass:"line-number"},[e._v("98")]),s("br"),s("span",{staticClass:"line-number"},[e._v("99")]),s("br"),s("span",{staticClass:"line-number"},[e._v("100")]),s("br"),s("span",{staticClass:"line-number"},[e._v("101")]),s("br"),s("span",{staticClass:"line-number"},[e._v("102")]),s("br"),s("span",{staticClass:"line-number"},[e._v("103")]),s("br"),s("span",{staticClass:"line-number"},[e._v("104")]),s("br"),s("span",{staticClass:"line-number"},[e._v("105")]),s("br"),s("span",{staticClass:"line-number"},[e._v("106")]),s("br"),s("span",{staticClass:"line-number"},[e._v("107")]),s("br"),s("span",{staticClass:"line-number"},[e._v("108")]),s("br"),s("span",{staticClass:"line-number"},[e._v("109")]),s("br"),s("span",{staticClass:"line-number"},[e._v("110")]),s("br"),s("span",{staticClass:"line-number"},[e._v("111")]),s("br"),s("span",{staticClass:"line-number"},[e._v("112")]),s("br"),s("span",{staticClass:"line-number"},[e._v("113")]),s("br"),s("span",{staticClass:"line-number"},[e._v("114")]),s("br"),s("span",{staticClass:"line-number"},[e._v("115")]),s("br"),s("span",{staticClass:"line-number"},[e._v("116")]),s("br"),s("span",{staticClass:"line-number"},[e._v("117")]),s("br"),s("span",{staticClass:"line-number"},[e._v("118")]),s("br"),s("span",{staticClass:"line-number"},[e._v("119")]),s("br"),s("span",{staticClass:"line-number"},[e._v("120")]),s("br"),s("span",{staticClass:"line-number"},[e._v("121")]),s("br"),s("span",{staticClass:"line-number"},[e._v("122")]),s("br"),s("span",{staticClass:"line-number"},[e._v("123")]),s("br"),s("span",{staticClass:"line-number"},[e._v("124")]),s("br"),s("span",{staticClass:"line-number"},[e._v("125")]),s("br"),s("span",{staticClass:"line-number"},[e._v("126")]),s("br"),s("span",{staticClass:"line-number"},[e._v("127")]),s("br"),s("span",{staticClass:"line-number"},[e._v("128")]),s("br"),s("span",{staticClass:"line-number"},[e._v("129")]),s("br"),s("span",{staticClass:"line-number"},[e._v("130")]),s("br"),s("span",{staticClass:"line-number"},[e._v("131")]),s("br"),s("span",{staticClass:"line-number"},[e._v("132")]),s("br"),s("span",{staticClass:"line-number"},[e._v("133")]),s("br"),s("span",{staticClass:"line-number"},[e._v("134")]),s("br"),s("span",{staticClass:"line-number"},[e._v("135")]),s("br"),s("span",{staticClass:"line-number"},[e._v("136")]),s("br"),s("span",{staticClass:"line-number"},[e._v("137")]),s("br"),s("span",{staticClass:"line-number"},[e._v("138")]),s("br"),s("span",{staticClass:"line-number"},[e._v("139")]),s("br"),s("span",{staticClass:"line-number"},[e._v("140")]),s("br"),s("span",{staticClass:"line-number"},[e._v("141")]),s("br"),s("span",{staticClass:"line-number"},[e._v("142")]),s("br"),s("span",{staticClass:"line-number"},[e._v("143")]),s("br"),s("span",{staticClass:"line-number"},[e._v("144")]),s("br"),s("span",{staticClass:"line-number"},[e._v("145")]),s("br"),s("span",{staticClass:"line-number"},[e._v("146")]),s("br"),s("span",{staticClass:"line-number"},[e._v("147")]),s("br"),s("span",{staticClass:"line-number"},[e._v("148")]),s("br"),s("span",{staticClass:"line-number"},[e._v("149")]),s("br"),s("span",{staticClass:"line-number"},[e._v("150")]),s("br"),s("span",{staticClass:"line-number"},[e._v("151")]),s("br"),s("span",{staticClass:"line-number"},[e._v("152")]),s("br"),s("span",{staticClass:"line-number"},[e._v("153")]),s("br"),s("span",{staticClass:"line-number"},[e._v("154")]),s("br"),s("span",{staticClass:"line-number"},[e._v("155")]),s("br"),s("span",{staticClass:"line-number"},[e._v("156")]),s("br"),s("span",{staticClass:"line-number"},[e._v("157")]),s("br"),s("span",{staticClass:"line-number"},[e._v("158")]),s("br"),s("span",{staticClass:"line-number"},[e._v("159")]),s("br"),s("span",{staticClass:"line-number"},[e._v("160")]),s("br"),s("span",{staticClass:"line-number"},[e._v("161")]),s("br"),s("span",{staticClass:"line-number"},[e._v("162")]),s("br"),s("span",{staticClass:"line-number"},[e._v("163")]),s("br"),s("span",{staticClass:"line-number"},[e._v("164")]),s("br"),s("span",{staticClass:"line-number"},[e._v("165")]),s("br"),s("span",{staticClass:"line-number"},[e._v("166")]),s("br"),s("span",{staticClass:"line-number"},[e._v("167")]),s("br"),s("span",{staticClass:"line-number"},[e._v("168")]),s("br"),s("span",{staticClass:"line-number"},[e._v("169")]),s("br"),s("span",{staticClass:"line-number"},[e._v("170")]),s("br"),s("span",{staticClass:"line-number"},[e._v("171")]),s("br"),s("span",{staticClass:"line-number"},[e._v("172")]),s("br"),s("span",{staticClass:"line-number"},[e._v("173")]),s("br"),s("span",{staticClass:"line-number"},[e._v("174")]),s("br"),s("span",{staticClass:"line-number"},[e._v("175")]),s("br"),s("span",{staticClass:"line-number"},[e._v("176")]),s("br"),s("span",{staticClass:"line-number"},[e._v("177")]),s("br"),s("span",{staticClass:"line-number"},[e._v("178")]),s("br"),s("span",{staticClass:"line-number"},[e._v("179")]),s("br"),s("span",{staticClass:"line-number"},[e._v("180")]),s("br"),s("span",{staticClass:"line-number"},[e._v("181")]),s("br"),s("span",{staticClass:"line-number"},[e._v("182")]),s("br"),s("span",{staticClass:"line-number"},[e._v("183")]),s("br")])]),s("h3",{attrs:{id:"_1-halted和paused"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-halted和paused"}},[e._v("#")]),e._v(" 1.halted和paused")]),e._v(" "),s("p",[e._v("这是两个boolean值的标志参数，分别表示：停止和暂停；halted默认为false，当QuartzScheduler执行shutdown()时才会更新为true；paused默认是true，当QuartzScheduler执行start()时"),s("br"),e._v("\n更新为false；正常启动之后QuartzSchedulerThread就可以往下执行了；")]),e._v(" "),s("h3",{attrs:{id:"_2-availthreadcount"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-availthreadcount"}},[e._v("#")]),e._v(" 2.availThreadCount")]),e._v(" "),s("p",[e._v("查询SimpleThreadPool是否有可用的WorkerThread，如果availThreadCount>0可以往下继续执行其他逻辑，否则继续检查；")]),e._v(" "),s("h3",{attrs:{id:"_3-acquirenexttriggers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-acquirenexttriggers"}},[e._v("#")]),e._v(" 3.acquireNextTriggers")]),e._v(" "),s("p",[e._v("查询一段时间内将要被调度的triggers，这里有3个比较重要的参数分别是：idleWaitTime，maxBatchSize，batchTimeWindow，这3个参数都可以在配置文件中进行配置：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("org.quartz.scheduler.idleWaitTime:30000\norg.quartz.scheduler.batchTriggerAcquisitionMaxCount:1\norg.quartz.scheduler.batchTriggerAcquisitionFireAheadTimeWindow:0\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("idleWaitTime:在调度程序处于空闲状态时，调度程序将在重新查询可用触发器之前等待的时间量（以毫秒为单位），默认是30秒;"),s("br"),e._v("\nbatchTriggerAcquisitionMaxCount:允许调度程序节点一次获取（用于触发）的触发器的最大数量，默认是1;"),s("br"),e._v("\nbatchTriggerAcquisitionFireAheadTimeWindow:允许触发器在其预定的火灾时间之前被获取和触发的时间（毫秒）的时间量，默认是0;")]),e._v(" "),s("p",[e._v("往下继续查看acquireNextTriggers方法源码：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public List<OperableTrigger> acquireNextTriggers(final long noLaterThan, final int maxCount, final long timeWindow)\n    throws JobPersistenceException {\n     \n    String lockName;\n    if(isAcquireTriggersWithinLock() || maxCount > 1) { \n        lockName = LOCK_TRIGGER_ACCESS;\n    } else {\n        lockName = null;\n    }\n    return executeInNonManagedTXLock(lockName, \n            new TransactionCallback<List<OperableTrigger>>() {\n                public List<OperableTrigger> execute(Connection conn) throws JobPersistenceException {\n                    return acquireNextTrigger(conn, noLaterThan, maxCount, timeWindow);\n                }\n            },\n            ......\n            });\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br")])]),s("p",[e._v("可以发现只有在设置了acquireTriggersWithinLock或者batchTriggerAcquisitionMaxCount>1情况下才使用LOCK_TRIGGER_ACCESS锁，也就是说在默认参数配置的情况下，这里是没有使用锁的，"),s("br"),e._v("\n那么如果多个节点同时去执行acquireNextTriggers，会不会出现同一个trigger在多个节点都被执行？"),s("br"),e._v("\n注：acquireTriggersWithinLock可以在配置文件中进行配置：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("org.quartz.jobStore.acquireTriggersWithinLock=true\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("acquireTriggersWithinLock：获取triggers的时候是否需要使用锁，默认是false，如果batchTriggerAcquisitionMaxCount>1最好同时设置acquireTriggersWithinLock为true；")]),e._v(" "),s("p",[e._v("带着问题继续查看TransactionCallback内部的acquireNextTrigger方法源码：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('protected List<OperableTrigger> acquireNextTrigger(Connection conn, long noLaterThan, int maxCount, long timeWindow)\n    throws JobPersistenceException {\n    if (timeWindow < 0) {\n      throw new IllegalArgumentException();\n    }\n     \n    List<OperableTrigger> acquiredTriggers = new ArrayList<OperableTrigger>();\n    Set<JobKey> acquiredJobKeysForNoConcurrentExec = new HashSet<JobKey>();\n    final int MAX_DO_LOOP_RETRY = 3;\n    int currentLoopCount = 0;\n    do {\n        currentLoopCount ++;\n        try {\n            List<TriggerKey> keys = getDelegate().selectTriggerToAcquire(conn, noLaterThan + timeWindow, getMisfireTime(), maxCount);\n             \n            // No trigger is ready to fire yet.\n            if (keys == null || keys.size() == 0)\n                return acquiredTriggers;\n \n            long batchEnd = noLaterThan;\n \n            for(TriggerKey triggerKey: keys) {\n                // If our trigger is no longer available, try a new one.\n                OperableTrigger nextTrigger = retrieveTrigger(conn, triggerKey);\n                if(nextTrigger == null) {\n                    continue; // next trigger\n                }\n                 \n                // If trigger\'s job is set as @DisallowConcurrentExecution, and it has already been added to result, then\n                // put it back into the timeTriggers set and continue to search for next trigger.\n                JobKey jobKey = nextTrigger.getJobKey();\n                JobDetail job;\n                try {\n                    job = retrieveJob(conn, jobKey);\n                } catch (JobPersistenceException jpe) {\n                    try {\n                        getLog().error("Error retrieving job, setting trigger state to ERROR.", jpe);\n                        getDelegate().updateTriggerState(conn, triggerKey, STATE_ERROR);\n                    } catch (SQLException sqle) {\n                        getLog().error("Unable to set trigger state to ERROR.", sqle);\n                    }\n                    continue;\n                }\n                 \n                if (job.isConcurrentExectionDisallowed()) {\n                    if (acquiredJobKeysForNoConcurrentExec.contains(jobKey)) {\n                        continue; // next trigger\n                    } else {\n                        acquiredJobKeysForNoConcurrentExec.add(jobKey);\n                    }\n                }\n                 \n                if (nextTrigger.getNextFireTime().getTime() > batchEnd) {\n                  break;\n                }\n                // We now have a acquired trigger, let\'s add to return list.\n                // If our trigger was no longer in the expected state, try a new one.\n                int rowsUpdated = getDelegate().updateTriggerStateFromOtherState(conn, triggerKey, STATE_ACQUIRED, STATE_WAITING);\n                if (rowsUpdated <= 0) {\n                    continue; // next trigger\n                }\n                nextTrigger.setFireInstanceId(getFiredTriggerRecordId());\n                getDelegate().insertFiredTrigger(conn, nextTrigger, STATE_ACQUIRED, null);\n \n                if(acquiredTriggers.isEmpty()) {\n                    batchEnd = Math.max(nextTrigger.getNextFireTime().getTime(), System.currentTimeMillis()) + timeWindow;\n                }\n                acquiredTriggers.add(nextTrigger);\n            }\n \n            // if we didn\'t end up with any trigger to fire from that first\n            // batch, try again for another batch. We allow with a max retry count.\n            if(acquiredTriggers.size() == 0 && currentLoopCount < MAX_DO_LOOP_RETRY) {\n                continue;\n            }\n             \n            // We are done with the while loop.\n            break;\n        } catch (Exception e) {\n            throw new JobPersistenceException(\n                      "Couldn\'t acquire next trigger: " + e.getMessage(), e);\n        }\n    } while (true);\n     \n    // Return the acquired trigger list\n    return acquiredTriggers;\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br"),s("span",{staticClass:"line-number"},[e._v("54")]),s("br"),s("span",{staticClass:"line-number"},[e._v("55")]),s("br"),s("span",{staticClass:"line-number"},[e._v("56")]),s("br"),s("span",{staticClass:"line-number"},[e._v("57")]),s("br"),s("span",{staticClass:"line-number"},[e._v("58")]),s("br"),s("span",{staticClass:"line-number"},[e._v("59")]),s("br"),s("span",{staticClass:"line-number"},[e._v("60")]),s("br"),s("span",{staticClass:"line-number"},[e._v("61")]),s("br"),s("span",{staticClass:"line-number"},[e._v("62")]),s("br"),s("span",{staticClass:"line-number"},[e._v("63")]),s("br"),s("span",{staticClass:"line-number"},[e._v("64")]),s("br"),s("span",{staticClass:"line-number"},[e._v("65")]),s("br"),s("span",{staticClass:"line-number"},[e._v("66")]),s("br"),s("span",{staticClass:"line-number"},[e._v("67")]),s("br"),s("span",{staticClass:"line-number"},[e._v("68")]),s("br"),s("span",{staticClass:"line-number"},[e._v("69")]),s("br"),s("span",{staticClass:"line-number"},[e._v("70")]),s("br"),s("span",{staticClass:"line-number"},[e._v("71")]),s("br"),s("span",{staticClass:"line-number"},[e._v("72")]),s("br"),s("span",{staticClass:"line-number"},[e._v("73")]),s("br"),s("span",{staticClass:"line-number"},[e._v("74")]),s("br"),s("span",{staticClass:"line-number"},[e._v("75")]),s("br"),s("span",{staticClass:"line-number"},[e._v("76")]),s("br"),s("span",{staticClass:"line-number"},[e._v("77")]),s("br"),s("span",{staticClass:"line-number"},[e._v("78")]),s("br"),s("span",{staticClass:"line-number"},[e._v("79")]),s("br"),s("span",{staticClass:"line-number"},[e._v("80")]),s("br"),s("span",{staticClass:"line-number"},[e._v("81")]),s("br"),s("span",{staticClass:"line-number"},[e._v("82")]),s("br"),s("span",{staticClass:"line-number"},[e._v("83")]),s("br"),s("span",{staticClass:"line-number"},[e._v("84")]),s("br"),s("span",{staticClass:"line-number"},[e._v("85")]),s("br"),s("span",{staticClass:"line-number"},[e._v("86")]),s("br"),s("span",{staticClass:"line-number"},[e._v("87")]),s("br")])]),s("p",[e._v("首先看一下在执行selectTriggerToAcquire方法时引入了新的参数：misfireTime=当前时间-MisfireThreshold，MisfireThreshold可以在配置文件中进行配置：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("org.quartz.jobStore.misfireThreshold:?60000\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("misfireThreshold：叫触发器超时，比如有10个线程，但是有11个任务，这样就有一个任务被延迟执行了，可以理解为调度引擎可以忍受这个超时的时间；具体的查询SQL如下所示：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("SELECT TRIGGER_NAME, TRIGGER_GROUP, NEXT_FIRE_TIME, PRIORITY\n  FROM qrtz_TRIGGERS\n WHERE SCHED_NAME = 'myScheduler'\n   AND TRIGGER_STATE = 'WAITING'\n   AND NEXT_FIRE_TIME <= noLaterThan\n   AND (MISFIRE_INSTR = -1 OR\n       (MISFIRE_INSTR != -1 AND NEXT_FIRE_TIME >= noEarlierThan))\n ORDER BY NEXT_FIRE_TIME ASC, PRIORITY DESC\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("这里的noLaterThan=当前时间+idleWaitTime+batchTriggerAcquisitionFireAheadTimeWindow，"),s("br"),e._v("\nnoEarlierThan=当前时间-MisfireThreshold；"),s("br"),e._v("\n在查询完之后，会遍历执行updateTriggerStateFromOtherState()方法更新trigger的状态从STATE_WAITING到STATE_ACQUIRED，并且会判断rowsUpdated是否大于0，这样就算多个节点都查询到相同的trigger，但是肯定只会有一个节点更新成功；更新完状态之后，往qrtz_fired_triggers表中插入一条记录，表示当前trigger已经触发，状态为STATE_ACQUIRED；")]),e._v(" "),s("h3",{attrs:{id:"_4-executeinnonmanagedtxlock"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-executeinnonmanagedtxlock"}},[e._v("#")]),e._v(" 4.executeInNonManagedTXLock")]),e._v(" "),s("p",[e._v("Quartz的分布式锁被用在很多地方，下面具体看一下Quartz是如何实现分布式锁的，executeInNonManagedTXLock方法源码如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("protected <T> T executeInNonManagedTXLock(        String lockName,         TransactionCallback<T> txCallback, final TransactionValidator<T> txValidator) throws JobPersistenceException {    boolean transOwner = false;    Connection conn = null;    try {        if (lockName != null) {            // If we aren't using db locks, then delay getting DB connection             // until after acquiring the lock since it isn't needed.            if (getLockHandler().requiresConnection()) {                conn = getNonManagedTXConnection();            }                         transOwner = getLockHandler().obtainLock(conn, lockName);        }                 if (conn == null) {            conn = getNonManagedTXConnection();        }                 final T result = txCallback.execute(conn);        try {            commitConnection(conn);        } catch (JobPersistenceException e) {            rollbackConnection(conn);            if (txValidator == null || !retryExecuteInNonManagedTXLock(lockName, new TransactionCallback<Boolean>() {                @Override                public Boolean execute(Connection conn) throws JobPersistenceException {                    return txValidator.validate(conn, result);                }            })) {                throw e;            }        }         Long sigTime = clearAndGetSignalSchedulingChangeOnTxCompletion();        if(sigTime != null && sigTime >= 0) {            signalSchedulingChangeImmediately(sigTime);        }                 return result;    } catch (JobPersistenceException e) {        rollbackConnection(conn);        throw e;    } catch (RuntimeException e) {        rollbackConnection(conn);        throw new JobPersistenceException(\"Unexpected runtime exception: \"                + e.getMessage(), e);    } finally {        try {            releaseLock(lockName, transOwner);        } finally {            cleanupConnection(conn);        }    }}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("大致分成3个步骤：获取锁，执行逻辑，释放锁；getLockHandler().obtainLock表示获取锁txCallback.execute(conn)表示执行逻辑，commitConnection(conn)表示释放锁"),s("br"),e._v("\nQuartz的分布式锁接口类是Semaphore，默认具体的实现是StdRowLockSemaphore，具体接口如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public interface Semaphore {    boolean obtainLock(Connection conn, String lockName) throws LockException;    void releaseLock(String lockName) throws LockException;    boolean requiresConnection();}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("具体看一下obtainLock()是如何获取锁的，源码如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('public boolean obtainLock(Connection conn, String lockName)    throws LockException {    if (!isLockOwner(lockName)) {        executeSQL(conn, lockName, expandedSQL, expandedInsertSQL);        getThreadLocks().add(lockName);            } else if(log.isDebugEnabled()) {            }    return true;} protected void executeSQL(Connection conn, final String lockName, final String expandedSQL, final String expandedInsertSQL) throws LockException {    PreparedStatement ps = null;    ResultSet rs = null;    SQLException initCause = null;         int count = 0;    do {        count++;        try {            ps = conn.prepareStatement(expandedSQL);            ps.setString(1, lockName);                         rs = ps.executeQuery();            if (!rs.next()) {                getLog().debug(                        "Inserting new lock row for lock: \'" + lockName + "\' being obtained by thread: " +                         Thread.currentThread().getName());                rs.close();                rs = null;                ps.close();                ps = null;                ps = conn.prepareStatement(expandedInsertSQL);                ps.setString(1, lockName);                 int res = ps.executeUpdate();                                 if(res != 1) {                   if(count < 3) {                        try {                            Thread.sleep(1000L);                        } catch (InterruptedException ignore) {                            Thread.currentThread().interrupt();                        }                        continue;                    }                }            }                         return; // obtained lock, go        } catch (SQLException sqle) {            ......    } while(count < 4); }\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("obtainLock首先判断是否已经获取到锁，如果没有执行方法executeSQL，其中有两条重要的SQL，分别是：expandedSQL和expandedInsertSQL，以SCHED_NAME = ‘myScheduler’为例：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("SELECT * FROM QRTZ_LOCKS WHERE SCHED_NAME = 'myScheduler' AND LOCK_NAME = ? FOR UPDATEINSERT INTO QRTZ_LOCKS(SCHED_NAME, LOCK_NAME) VALUES ('myScheduler', ?)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("select语句后面添加了FOR UPDATE，如果LOCK_NAME存在，当多个节点去执行此SQL时，只有第一个节点会成功，其他的节点都将进入等待；"),s("br"),e._v("\n如果LOCK_NAME不存在，多个节点同时执行expandedInsertSQL，只会有一个节点插入成功，执行插入失败的节点将进入重试，重新执行expandedSQL；"),s("br"),e._v("\ntxCallback执行完之后，执行commitConnection操作，这样当前节点就释放了LOCK_NAME，其他节点可以竞争获取锁，最后执行了releaseLock；")]),e._v(" "),s("h3",{attrs:{id:"_5-triggersfired"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-triggersfired"}},[e._v("#")]),e._v(" 5.triggersFired")]),e._v(" "),s("p",[e._v("表示触发trigger，具体代码如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('protected TriggerFiredBundle triggerFired(Connection conn,        OperableTrigger trigger)    throws JobPersistenceException {    JobDetail job;    Calendar cal = null;     // Make sure trigger wasn\'t deleted, paused, or completed...    try { // if trigger was deleted, state will be STATE_DELETED        String state = getDelegate().selectTriggerState(conn,                trigger.getKey());        if (!state.equals(STATE_ACQUIRED)) {            return null;        }    } catch (SQLException e) {        throw new JobPersistenceException("Couldn\'t select trigger state: "                + e.getMessage(), e);    }     try {        job = retrieveJob(conn, trigger.getJobKey());        if (job == null) { return null; }    } catch (JobPersistenceException jpe) {        try {            getLog().error("Error retrieving job, setting trigger state to ERROR.", jpe);            getDelegate().updateTriggerState(conn, trigger.getKey(),                    STATE_ERROR);        } catch (SQLException sqle) {            getLog().error("Unable to set trigger state to ERROR.", sqle);        }        throw jpe;    }     if (trigger.getCalendarName() != null) {        cal = retrieveCalendar(conn, trigger.getCalendarName());        if (cal == null) { return null; }    }     try {        getDelegate().updateFiredTrigger(conn, trigger, STATE_EXECUTING, job);    } catch (SQLException e) {        throw new JobPersistenceException("Couldn\'t insert fired trigger: "                + e.getMessage(), e);    }     Date prevFireTime = trigger.getPreviousFireTime();     // call triggered - to update the trigger\'s next-fire-time state...    trigger.triggered(cal);     String state = STATE_WAITING;    boolean force = true;         if (job.isConcurrentExectionDisallowed()) {        state = STATE_BLOCKED;        force = false;        try {            getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),                    STATE_BLOCKED, STATE_WAITING);            getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),                    STATE_BLOCKED, STATE_ACQUIRED);            getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),                    STATE_PAUSED_BLOCKED, STATE_PAUSED);        } catch (SQLException e) {            throw new JobPersistenceException(                    "Couldn\'t update states of blocked triggers: "                            + e.getMessage(), e);        }    }              if (trigger.getNextFireTime() == null) {        state = STATE_COMPLETE;        force = true;    }     storeTrigger(conn, trigger, job, true, state, force, false);     job.getJobDataMap().clearDirtyFlag();     return new TriggerFiredBundle(job, trigger, cal, trigger.getKey().getGroup()            .equals(Scheduler.DEFAULT_RECOVERY_GROUP), new Date(), trigger            .getPreviousFireTime(), prevFireTime, trigger.getNextFireTime());}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("首先查询trigger的状态是否STATE_ACQUIRED状态，如果不是直接返回null；然后通过通过jobKey获取对应的jobDetail，更新对应的FiredTrigger为EXECUTING状态；最后判定job的DisallowConcurrentExecution是否开启，如果开启了不能并发执行job，那么trigger的状态为STATE_BLOCKED状态，否则为STATE_WAITING；如果状态为STATE_BLOCKED，那么下次调度"),s("br"),e._v("\n对应的trigger不会被拉取，只有等对应的job执行完之后，更新状态为STATE_WAITING之后才可以执行，保证了job的串行；")]),e._v(" "),s("h3",{attrs:{id:"_6-执行job"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-执行job"}},[e._v("#")]),e._v(" 6.执行job")]),e._v(" "),s("p",[e._v("通过ThreadPool来执行封装job的JobRunShell；")]),e._v(" "),s("h2",{attrs:{id:"问题解释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题解释"}},[e._v("#")]),e._v(" "),s("strong",[e._v("问题解释")])]),e._v(" "),s("p",[e._v("在文章Spring整合Quartz分布式调度中，最后做了几次测试分布式调度，现在可以做出相应的解释")]),e._v(" "),s("h3",{attrs:{id:"_1-同一trigger同一时间只会在一个节点执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-同一trigger同一时间只会在一个节点执行"}},[e._v("#")]),e._v(" 1.同一trigger同一时间只会在一个节点执行")]),e._v(" "),s("p",[e._v("上文中可以发现Quartz使用了分布式锁和状态来保证只有一个节点能执行；")]),e._v(" "),s("h3",{attrs:{id:"_2-任务没有执行完-可以重新开始"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-任务没有执行完-可以重新开始"}},[e._v("#")]),e._v(" 2.任务没有执行完，可以重新开始")]),e._v(" "),s("p",[e._v("因为调度线程和任务执行线程是分开的，认为执行在Threadpool中执行，互相不影响；")]),e._v(" "),s("h3",{attrs:{id:"_3-通过disallowconcurrentexecution注解保证任务的串行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-通过disallowconcurrentexecution注解保证任务的串行"}},[e._v("#")]),e._v(" 3.通过DisallowConcurrentExecution注解保证任务的串行")]),e._v(" "),s("p",[e._v("在triggerFired中如果使用了DisallowConcurrentExecution，会引入STATE_BLOCKED状态，保证任务的串行；")]),e._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" "),s("strong",[e._v("总结")])]),e._v(" "),s("p",[e._v("本文从源码的角度大致介绍了一下Quartz调度的流程，当然太细节的东西没有去深入；通过本文大致可以对多节点调度产生的现象做一个合理的解释。")])])}),[],!1,null,null,null);n.default=r.exports}}]);