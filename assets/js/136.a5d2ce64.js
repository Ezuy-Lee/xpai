(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{561:function(e,t,a){"use strict";a.r(t);var n=a(15),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"dubbo整体设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dubbo整体设计"}},[e._v("#")]),e._v(" Dubbo整体设计")]),e._v(" "),a("p",[e._v("关于Dubbo的整体设计可以查看官方文档，下图可以清晰的表达Dubbo的整体设计："),a("br"),e._v(" "),a("img",{attrs:{src:"https://oscimg.oschina.net/oscnet/9972a3320970b9aee779f182e17f83c892a.jpg",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"_1-图例说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-图例说明"}},[e._v("#")]),e._v(" 1.图例说明")]),e._v(" "),a("p",[e._v("图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口；"),a("br"),e._v("\n图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系；"),a("br"),e._v("\n图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类；"),a("br"),e._v("\n图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法；")]),e._v(" "),a("h3",{attrs:{id:"_2-各层说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-各层说明"}},[e._v("#")]),e._v(" 2.各层说明")]),e._v(" "),a("p",[e._v("config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类；"),a("br"),e._v("\nproxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory；"),a("br"),e._v("\nregistry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService；"),a("br"),e._v("\ncluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance；"),a("br"),e._v("\nmonitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService；"),a("br"),e._v("\nprotocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter；"),a("br"),e._v("\nexchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer；"),a("br"),e._v("\ntransport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec；"),a("br"),e._v("\nserialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool；")]),e._v(" "),a("p",[e._v("本文将从最底层的serialize层开始来对dubbo进行源码分析；")]),e._v(" "),a("h2",{attrs:{id:"通讯框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通讯框架"}},[e._v("#")]),e._v(" 通讯框架")]),e._v(" "),a("p",[e._v("dubbo的底层通讯使用的是第三方框架，包括：netty，netty4，mina和grizzly；默认使用的是netty，分别提供了server端(服务提供方)和client端(服务消费方)；下面已使用的netty为例来看那一下NettyServer的部分代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('protected void doOpen() throws Throwable {\n        NettyHelper.setNettyLoggerFactory();\n        ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory("NettyServerBoss", true));\n        ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory("NettyServerWorker", true));\n        ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));\n        bootstrap = new ServerBootstrap(channelFactory);\n \n        final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n        channels = nettyHandler.getChannels();\n        // https://issues.jboss.org/browse/NETTY-365\n        // https://issues.jboss.org/browse/NETTY-379\n        // final Timer timer = new HashedWheelTimer(new NamedThreadFactory("NettyIdleTimer", true));\n        bootstrap.setOption("child.tcpNoDelay", true);\n        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n            @Override\n            public ChannelPipeline getPipeline() {\n                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);\n                ChannelPipeline pipeline = Channels.pipeline();\n                /*int idleTimeout = getIdleTimeout();\n                if (idleTimeout > 10000) {\n                    pipeline.addLast("timer", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));\n                }*/\n                pipeline.addLast("decoder", adapter.getDecoder());\n                pipeline.addLast("encoder", adapter.getEncoder());\n                pipeline.addLast("handler", nettyHandler);\n                return pipeline;\n            }\n        });\n        // bind\n        channel = bootstrap.bind(getBindAddress());\n    }\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br"),a("span",{staticClass:"line-number"},[e._v("27")]),a("br"),a("span",{staticClass:"line-number"},[e._v("28")]),a("br"),a("span",{staticClass:"line-number"},[e._v("29")]),a("br"),a("span",{staticClass:"line-number"},[e._v("30")]),a("br"),a("span",{staticClass:"line-number"},[e._v("31")]),a("br")])]),a("p",[e._v("在启动服务提供方时就会调用此doOpen方法，用来启动服务端口，供消费方连接；以上代码就是常规的启动nettyServer端代码，因为本文重点介绍dubbo的序列化，所以这里主要看decoder和encoder，这两个类分别定义在NettyCodecAdapter中：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("private final ChannelHandler encoder = new InternalEncoder();\nprivate final ChannelHandler decoder = new InternalDecoder();\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("h3",{attrs:{id:"_1-编码器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-编码器"}},[e._v("#")]),e._v(" 1.编码器")]),e._v(" "),a("p",[e._v("在NettyCodecAdapter定义了内部类InternalEncoder：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("private class InternalEncoder extends OneToOneEncoder {\n \n        @Override\n        protected Object encode(ChannelHandlerContext ctx, Channel ch, Object msg) throws Exception {\n            com.alibaba.dubbo.remoting.buffer.ChannelBuffer buffer =\n                    com.alibaba.dubbo.remoting.buffer.ChannelBuffers.dynamicBuffer(1024);\n            NettyChannel channel = NettyChannel.getOrAddChannel(ch, url, handler);\n            try {\n                codec.encode(channel, buffer, msg);\n            } finally {\n                NettyChannel.removeChannelIfDisconnected(ch);\n            }\n            return ChannelBuffers.wrappedBuffer(buffer.toByteBuffer());\n        }\n    }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])]),a("p",[e._v("此类其实是对codec的包装，本身并没有做编码处理，下面重点看一下codec类，此类是一个接口类，有多种实现类，Codec2源码如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("@SPI\npublic interface Codec2 {\n \n    @Adaptive({Constants.CODEC_KEY})\n    void encode(Channel channel, ChannelBuffer buffer, Object message) throws IOException;\n \n    @Adaptive({Constants.CODEC_KEY})\n    Object decode(Channel channel, ChannelBuffer buffer) throws IOException;\n \n \n    enum DecodeResult {\n        NEED_MORE_INPUT, SKIP_SOME_INPUT\n    }\n \n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])]),a("p",[e._v("实现包括：TransportCodec，TelnetCodec，ExchangeCodec，DubboCountCodec以及ThriftCodec，当然也可以自行扩展；不可能启动时把每种类型都加载，dubbo是通过在配置文件中配置好所有的类型，然后在运行中需要什么类加载什么类，"),a("br"),e._v("\n配置文件的具体路径：META-INF/dubbo/internal/com.alibaba.dubbo.remoting.Codec2，内容如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("transport=com.alibaba.dubbo.remoting.transport.codec.TransportCodec\ntelnet=com.alibaba.dubbo.remoting.telnet.codec.TelnetCodec\nexchange=com.alibaba.dubbo.remoting.exchange.codec.ExchangeCodec\ndubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec\nthrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftCodec\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("获取具体Codec2的代码如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('protected static Codec2 getChannelCodec(URL url) {\n    String codecName = url.getParameter(Constants.CODEC_KEY, "telnet");\n    if (ExtensionLoader.getExtensionLoader(Codec2.class).hasExtension(codecName)) {\n        return ExtensionLoader.getExtensionLoader(Codec2.class).getExtension(codecName);\n    } else {\n        return new CodecAdapter(ExtensionLoader.getExtensionLoader(Codec.class)\n                .getExtension(codecName));\n    }\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("通过在url中获取是否有关键字codec，如果有的话就获取当前的值，dubbo默认的codec为dubbo；如果没有值默认为telnet；这里有默认值为dubbo，所以实现类DubboCountCodec会被ExtensionLoader进行加载并进行缓存，下面具体看一下DubboCountCodec的编解码；")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("private DubboCodec codec = new DubboCodec();\n \n@Override\npublic void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException {\n    codec.encode(channel, buffer, msg);\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("DubboCountCodec内部调用的是DubboCodec的encode方法，看一下如何对Request对象进行编码的，具体代码块如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("protected void encodeRequest(Channel channel, ChannelBuffer buffer, Request req) throws IOException {\n       Serialization serialization = getSerialization(channel);\n       // header.\n       byte[] header = new byte[HEADER_LENGTH];\n       // set magic number.\n       Bytes.short2bytes(MAGIC, header);\n \n       // set request and serialization flag.\n       header[2] = (byte) (FLAG_REQUEST | serialization.getContentTypeId());\n \n       if (req.isTwoWay()) header[2] |= FLAG_TWOWAY;\n       if (req.isEvent()) header[2] |= FLAG_EVENT;\n \n       // set request id.\n       Bytes.long2bytes(req.getId(), header, 4);\n \n       // encode request data.\n       int savedWriteIndex = buffer.writerIndex();\n       buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n       ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);\n       ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n       if (req.isEvent()) {\n           encodeEventData(channel, out, req.getData());\n       } else {\n           encodeRequestData(channel, out, req.getData(), req.getVersion());\n       }\n       out.flushBuffer();\n       if (out instanceof Cleanable) {\n           ((Cleanable) out).cleanup();\n       }\n       bos.flush();\n       bos.close();\n       int len = bos.writtenBytes();\n       checkPayload(channel, len);\n       Bytes.int2bytes(len, header, 12);\n \n       // write\n       buffer.writerIndex(savedWriteIndex);\n       buffer.writeBytes(header); // write header.\n       buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);\n   }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br"),a("span",{staticClass:"line-number"},[e._v("27")]),a("br"),a("span",{staticClass:"line-number"},[e._v("28")]),a("br"),a("span",{staticClass:"line-number"},[e._v("29")]),a("br"),a("span",{staticClass:"line-number"},[e._v("30")]),a("br"),a("span",{staticClass:"line-number"},[e._v("31")]),a("br"),a("span",{staticClass:"line-number"},[e._v("32")]),a("br"),a("span",{staticClass:"line-number"},[e._v("33")]),a("br"),a("span",{staticClass:"line-number"},[e._v("34")]),a("br"),a("span",{staticClass:"line-number"},[e._v("35")]),a("br"),a("span",{staticClass:"line-number"},[e._v("36")]),a("br"),a("span",{staticClass:"line-number"},[e._v("37")]),a("br"),a("span",{staticClass:"line-number"},[e._v("38")]),a("br"),a("span",{staticClass:"line-number"},[e._v("39")]),a("br"),a("span",{staticClass:"line-number"},[e._v("40")]),a("br"),a("span",{staticClass:"line-number"},[e._v("41")]),a("br")])]),a("p",[e._v("前两个字节存放了魔数：0xdabb；第三个字节包含了四个信息分别是：是否是请求消息(还是响应消息)，序列化类型，是否双向通信，是否是心跳消息；"),a("br"),e._v("\n在请求消息中直接跳过了第四个字节，直接在5-12位置存放了requestId，是一个long类型，第四个字节在如果是编码响应消息中会存放响应的状态；"),a("br"),e._v("\n代码往下看，buffer跳过了HEADER_LENGTH长度的字节，这里表示的是header部分的长度为16个字节，然后通过指定的序列化方式把data对象序列化到buffer中，序列化之后可以获取到data对象总共的字节数，用一个int类型来保存字节数，此int类型存放在header的最后四个字节中；"),a("br"),e._v("\n最后把buffer的writerIndex设置到写完header和data的地方，防止数据被覆盖；")]),e._v(" "),a("h3",{attrs:{id:"_2-解码器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-解码器"}},[e._v("#")]),e._v(" 2.解码器")]),e._v(" "),a("p",[e._v("在NettyCodecAdapter定义了内部类InternalEncoder，同样是调用DubboCodec的decode方法，部分代码如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('public Object decode(Channel channel, ChannelBuffer buffer) throws IOException {        int readable = buffer.readableBytes();        byte[] header = new byte[Math.min(readable, HEADER_LENGTH)];        buffer.readBytes(header);        return decode(channel, buffer, readable, header);    }     @Override    protected Object decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header) throws IOException {        // check magic number.        if (readable > 0 && header[0] != MAGIC_HIGH                || readable > 1 && header[1] != MAGIC_LOW) {            int length = header.length;            if (header.length < readable) {                header = Bytes.copyOf(header, readable);                buffer.readBytes(header, length, readable - length);            }            for (int i = 1; i < header.length - 1; i++) {                if (header[i] == MAGIC_HIGH && header[i + 1] == MAGIC_LOW) {                    buffer.readerIndex(buffer.readerIndex() - header.length + i);                    header = Bytes.copyOf(header, i);                    break;                }            }            return super.decode(channel, buffer, readable, header);        }        // check length.        if (readable < HEADER_LENGTH) {            return DecodeResult.NEED_MORE_INPUT;        }         // get data length.        int len = Bytes.bytes2int(header, 12);        checkPayload(channel, len);         int tt = len + HEADER_LENGTH;        if (readable < tt) {            return DecodeResult.NEED_MORE_INPUT;        }         // limit input stream.        ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len);         try {            return decodeBody(channel, is, header);        } finally {            if (is.available() > 0) {                try {                    if (logger.isWarnEnabled()) {                        logger.warn("Skip input stream " + is.available());                    }                    StreamUtils.skipUnusedStream(is);                } catch (IOException e) {                    logger.warn(e.getMessage(), e);                }            }        }    }\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("首先读取Math.min(readable, HEADER_LENGTH)，如果readable小于HEADER_LENGTH，表示接收方连头部的16个字节还没接受完，需要等待接收；正常header接收完之后需要进行检查，主要包括：魔数的检查，header消息长度检查，消息体长度检查(检查消息体是否已经接收完成)；检查完之后需要对消息体进行反序列化，具体在decodeBody方法中：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('@Override    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {        byte flag = header[2], proto = (byte) (flag & SERIALIZATION_MASK);        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);        // get request id.        long id = Bytes.bytes2long(header, 4);        if ((flag & FLAG_REQUEST) == 0) {            // decode response.            Response res = new Response(id);            if ((flag & FLAG_EVENT) != 0) {                res.setEvent(Response.HEARTBEAT_EVENT);            }            // get status.            byte status = header[3];            res.setStatus(status);            if (status == Response.OK) {                try {                    Object data;                    if (res.isHeartbeat()) {                        data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));                    } else if (res.isEvent()) {                        data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));                    } else {                        DecodeableRpcResult result;                        if (channel.getUrl().getParameter(                                Constants.DECODE_IN_IO_THREAD_KEY,                                Constants.DEFAULT_DECODE_IN_IO_THREAD)) {                            result = new DecodeableRpcResult(channel, res, is,                                    (Invocation) getRequestData(id), proto);                            result.decode();                        } else {                            result = new DecodeableRpcResult(channel, res,                                    new UnsafeByteArrayInputStream(readMessageData(is)),                                    (Invocation) getRequestData(id), proto);                        }                        data = result;                    }                    res.setResult(data);                } catch (Throwable t) {                    if (log.isWarnEnabled()) {                        log.warn("Decode response failed: " + t.getMessage(), t);                    }                    res.setStatus(Response.CLIENT_ERROR);                    res.setErrorMessage(StringUtils.toString(t));                }            } else {                res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());            }            return res;        } else {            // decode request.            Request req = new Request(id);            req.setVersion(Version.getProtocolVersion());            req.setTwoWay((flag & FLAG_TWOWAY) != 0);            if ((flag & FLAG_EVENT) != 0) {                req.setEvent(Request.HEARTBEAT_EVENT);            }            try {                Object data;                if (req.isHeartbeat()) {                    data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));                } else if (req.isEvent()) {                    data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));                } else {                    DecodeableRpcInvocation inv;                    if (channel.getUrl().getParameter(                            Constants.DECODE_IN_IO_THREAD_KEY,                            Constants.DEFAULT_DECODE_IN_IO_THREAD)) {                        inv = new DecodeableRpcInvocation(channel, req, is, proto);                        inv.decode();                    } else {                        inv = new DecodeableRpcInvocation(channel, req,                                new UnsafeByteArrayInputStream(readMessageData(is)), proto);                    }                    data = inv;                }                req.setData(data);            } catch (Throwable t) {                if (log.isWarnEnabled()) {                    log.warn("Decode request failed: " + t.getMessage(), t);                }                // bad request                req.setBroken(true);                req.setData(t);            }            return req;        }    }\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("首先通过解析header部分的第三个字节，识别出是请求消息还是响应消息，还有使用哪种类型的序列化方式，然后分别进行序列化；")]),e._v(" "),a("h2",{attrs:{id:"序列化和反序列化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#序列化和反序列化"}},[e._v("#")]),e._v(" 序列化和反序列化")]),e._v(" "),a("p",[e._v("通过以上对编码器解码器的了解，在编码器中需要序列化Request/Response，在解码器中需要序列化Request/Response，下面具体看看序列化和反序列化；")]),e._v(" "),a("h3",{attrs:{id:"_1-序列化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-序列化"}},[e._v("#")]),e._v(" 1.序列化")]),e._v(" "),a("p",[e._v("在编码器中需要获取具体的Serialization，具体代码如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public static Serialization getSerialization(URL url) {    return ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(            url.getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION));}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("同获取codec的方式，dubbo也提供了多种序列化方式，同时可以自定义扩展；通过在url中获取serialization关键字，如果获取不到默认为hession2；同样多种序列化类也配置在一个文件中，"),a("br"),e._v("\n路径：META-INF/dubbo/internal/com.alibaba.dubbo.common.serialize.Serialization，具体内容如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("fastjson=com.alibaba.dubbo.common.serialize.fastjson.FastJsonSerializationfst=com.alibaba.dubbo.common.serialize.fst.FstSerializationhessian2=com.alibaba.dubbo.common.serialize.hessian2.Hessian2Serializationjava=com.alibaba.dubbo.common.serialize.java.JavaSerializationcompactedjava=com.alibaba.dubbo.common.serialize.java.CompactedJavaSerializationnativejava=com.alibaba.dubbo.common.serialize.nativejava.NativeJavaSerializationkryo=com.alibaba.dubbo.common.serialize.kryo.KryoSerialization\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("dubbo默认提供了fastjson，fst，hessian2，java，compactedjava，nativejava和kryo多种序列化方式；"),a("br"),e._v("\n每种序列化方式都需要实现如下三个接口类：Serialization，ObjectInput以及ObjectOutput；"),a("br"),e._v("\nSerialization接口类：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public interface Serialization {     byte getContentTypeId();     String getContentType();     @Adaptive    ObjectOutput serialize(URL url, OutputStream output) throws IOException;     @Adaptive    ObjectInput deserialize(URL url, InputStream input) throws IOException; }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("其中的ContentTypeId就是在header中存放的序列化类型，反序列化的时候需要通过此id获取具体的Serialization，所以此ContentTypeId不能出现重复的，否则会被覆盖；"),a("br"),e._v("\nObjectInput接口类：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public interface ObjectOutput extends DataOutput {     void writeObject(Object obj) throws IOException;}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("ObjectOutput接口类：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public interface ObjectInput extends DataInput {     Object readObject() throws IOException, ClassNotFoundException;     <T> T readObject(Class<T> cls) throws IOException, ClassNotFoundException;     <T> T readObject(Class<T> cls, Type type) throws IOException, ClassNotFoundException;}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("分别提供了读取对象和写对象的接口方法，DataOutput和DataInput分别提供了对基本数据类型的读和写；序列化只需要调用writeObject方法将Data写入数据流即可；具体可以看一下编码器中调用的encodeRequestData方法：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("@Overrideprotected void encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) throws IOException {    RpcInvocation inv = (RpcInvocation) data;     out.writeUTF(version);    out.writeUTF(inv.getAttachment(Constants.PATH_KEY));    out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));     out.writeUTF(inv.getMethodName());    out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));    Object[] args = inv.getArguments();    if (args != null)        for (int i = 0; i < args.length; i++) {            out.writeObject(encodeInvocationArgument(channel, inv, i));        }    out.writeObject(inv.getAttachments());}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("默认使用的DubboCountCodec方式并没有直接将data写入流中，而是将RpcInvocation中的数据取出分别写入流；")]),e._v(" "),a("h3",{attrs:{id:"_2-反序列化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-反序列化"}},[e._v("#")]),e._v(" 2.反序列化")]),e._v(" "),a("p",[e._v("反序列化通过读取header中的序列化类型，然后通过如下方法获取具体的Serialization，具体在类CodecSupport中：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('public static Serialization getSerialization(URL url, Byte id) throws IOException {    Serialization serialization = getSerializationById(id);    String serializationName = url.getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION);    // Check if "serialization id" passed from network matches the id on this side(only take effect for JDK serialization), for security purpose.    if (serialization == null            || ((id == 3 || id == 7 || id == 4) && !(serializationName.equals(ID_SERIALIZATIONNAME_MAP.get(id))))) {        throw new IOException("Unexpected serialization id:" + id + " received from network, please check if the peer send the right id.");    }    return serialization;} private static Map<Byte, Serialization> ID_SERIALIZATION_MAP = new HashMap<Byte, Serialization>(); public static Serialization getSerializationById(Byte id) {    return ID_SERIALIZATION_MAP.get(id);}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("ID_SERIALIZATION_MAP存放着ContentTypeId和具体Serialization的对应关系，然后通过id获取具体的Serialization，然后根据写入的顺序读取数据；")]),e._v(" "),a("h2",{attrs:{id:"扩展序列化类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展序列化类型"}},[e._v("#")]),e._v(" 扩展序列化类型")]),e._v(" "),a("p",[e._v("dubbo本身对很多模块提供了很好的扩展功能，包括序列化功能，以下来分析一下如何使用protobuf来实现序列化方式；")]),e._v(" "),a("h3",{attrs:{id:"_1-整体代码结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-整体代码结构"}},[e._v("#")]),e._v(" 1.整体代码结构")]),e._v(" "),a("p",[e._v("首先看一下整体的代码结构，如下图所示："),a("br"),e._v(" "),a("img",{attrs:{src:"https://oscimg.oschina.net/oscnet/75248faf8301ebad82122ed7de00f7878f2.jpg",alt:""}}),a("br"),e._v("\n分别实现三个接口类：Serialization，ObjectInput以及ObjectOutput；然后在指定目录下提供一个文本文件；")]),e._v(" "),a("h3",{attrs:{id:"_2-引入扩展包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-引入扩展包"}},[e._v("#")]),e._v(" 2.引入扩展包")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<dependency>     <groupId>com.dyuproject.protostuff</groupId>     <artifactId>protostuff-core</artifactId>     <version>1.1.3</version></dependency><dependency>     <groupId>com.dyuproject.protostuff</groupId>     <artifactId>protostuff-runtime</artifactId>     <version>1.1.3</version></dependency>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"_3-实现接口objectinput和objectoutput"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-实现接口objectinput和objectoutput"}},[e._v("#")]),e._v(" 3.实现接口ObjectInput和ObjectOutput")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public class ProtobufObjectInput implements ObjectInput {     private ObjectInputStream input;     public ProtobufObjectInput(InputStream inputStream) throws IOException {        this.input = new ObjectInputStream(inputStream);    }     ....省略基础类型...         @Override    public Object readObject() throws IOException, ClassNotFoundException {        return input.readObject();    }     @Override    public <T> T readObject(Class<T> clazz) throws IOException {        try {            byte[] buffer = (byte[]) input.readObject();            input.read(buffer);            return SerializationUtil.deserialize(buffer, clazz);        } catch (Exception e) {            throw new IOException(e);        }     }     @Override    public <T> T readObject(Class<T> clazz, Type type) throws IOException {        try {            byte[] buffer = (byte[]) input.readObject();            input.read(buffer);            return SerializationUtil.deserialize(buffer, clazz);        } catch (Exception e) {            throw new IOException(e);        }    }} public class ProtobufObjectOutput implements ObjectOutput {     private ObjectOutputStream outputStream;     public ProtobufObjectOutput(OutputStream outputStream) throws IOException {        this.outputStream = new ObjectOutputStream(outputStream);    }     ....省略基础类型...     @Override    public void writeObject(Object v) throws IOException {        byte[] bytes = SerializationUtil.serialize(v);        outputStream.writeObject(bytes);        outputStream.flush();    }     @Override    public void flushBuffer() throws IOException {        outputStream.flush();    }}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("4.实现Serialization接口")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('public class ProtobufSerialization implements Serialization {     @Override    public byte getContentTypeId() {        return 10;    }     @Override    public String getContentType() {        return "x-application/protobuf";    }     @Override    public ObjectOutput serialize(URL url, OutputStream out) throws IOException {        return new ProtobufObjectOutput(out);    }     @Override    public ObjectInput deserialize(URL url, InputStream is) throws IOException {        return new ProtobufObjectInput(is);    }}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("这里引入了一个新的ContentTypeId，需要保证和dubbo里面已存在的不要冲突")]),e._v(" "),a("h3",{attrs:{id:"_5-指定目录提供注册"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-指定目录提供注册"}},[e._v("#")]),e._v(" 5.指定目录提供注册")]),e._v(" "),a("p",[e._v("在META-INF/dubbo/internal/目录下提供文件com.alibaba.dubbo.common.serialize.Serialization，内容如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("protobuf=com.dubboCommon.ProtobufSerialization\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"_6-在提供方配置新的序列化方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-在提供方配置新的序列化方式"}},[e._v("#")]),e._v(" 6.在提供方配置新的序列化方式")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<dubbo:protocol?name="dubbo"?port="20880"?serialization="protobuf"/>\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("这样就会使用新扩展的protobuf序列化方式来序列化对象；")]),e._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("本文从dubbo整体设计的最底层serialization层来分析和了解dubbo，后面会逐层进行分析，对dubbo有一个更加透彻的了解；")])])}),[],!1,null,null,null);t.default=s.exports}}]);