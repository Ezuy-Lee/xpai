(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{469:function(n,s,e){"use strict";e.r(s);var a=e(15),t=Object(a.a)({},(function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[e("strong",[n._v("协程")]),e("br"),n._v("\n协程(coroutine)最早由Melvin Conway在1963年提出并实现，一句话定义："),e("strong",[n._v("协程是用户态的轻量级的线程")])]),n._v(" "),e("p",[e("strong",[n._v("线程和协程")]),e("br"),n._v("\n线程和协程经常被放在一起比较；线程一旦被创建出来，编写者是无法决定什么时候获得或者放出时间片的，是由操作系统进行统一调度的；而协程对编写者来说是可以控制切换的时机，并且切换代价比线程小，因为不需要进行内核态的切换。"),e("br"),n._v("\n协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力, 但是可用通过多个(进程+多协程)模式来充分利用多CPU。"),e("br"),n._v("\n协程另外一个重要的特点就是：协程是作用在用户态，操作系统内核对于协程是毫无感知的，这样一来，协程的创建就类似于普通对象的创建，非常轻量级，从而使你可以在一个线程里面轻松创建数十万个协程，就像数十万次函数调用一样。可以想象一下，如果是在一个进程里面创建数十万个线程，结果该是怎样可怕。")]),n._v(" "),e("p",[e("strong",[n._v("进程、线程、协程")]),e("br"),n._v("\n进程：拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。"),e("br"),n._v("\n线程：拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。"),e("br"),n._v("\n协程：和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。")]),n._v(" "),e("p",[e("strong",[n._v("对协程的支持")]),e("br"),n._v("\nLua, Go，C#等语言原生支持协程"),e("br"),n._v("\nJava依赖第三方库，例如最为著名的协程开源库Kilim"),e("br"),n._v("\nC标准库里的函数setjmp和longjmp可以用来实现一种协程。")]),n._v(" "),e("p",[n._v("下面以lua语言为例子了解一下协程的工作机制")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function foo(a)\n    print("foo", a)\n    return coroutine.yield(2 * a)\nend\n\nco = coroutine.create(function ( a, b )\n    print("co-body_01", a, b)\n    local r = foo(a + 1)\n    print("co-body_02", r)\n    return "end"\nend)\n\nprint("---main---", coroutine.resume(co, 1, 10))\nprint("---main---", coroutine.resume(co, "r7"))\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br")])]),e("p",[n._v("运行结果：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("D:\\>luac text.lua\nD:\\>lua luac.out\nco-body_01      1       10\nfoo     2\n---main---      true    4\nco-body_02      r7\n---main---      true    end\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br")])]),e("p",[n._v("主要利用resume和yield两个函数进行控制切换的时机，具体描述看如下图(来源网上)：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://static.oschina.net/uploads/space/2016/1209/180946_r694_159239.png",alt:""}})]),n._v(" "),e("p",[n._v("协程经常被用在遇到io阻塞操作的时候，直接yield让出cpu，让下面的程序可以继续执行，等到操作完成了再重新resume恢复到上一次yield的地方；有没有觉得这种模式和我们碰到过的"),e("strong",[n._v("异步回调")]),n._v("模式有点类似，下面可以进行一个对比。")]),n._v(" "),e("p",[e("strong",[n._v("协程和callback")]),e("br"),n._v("\n协程经常被用来和callback进行比较，因为都实现了异步通信的功能；下面以一个具体的场景来描述2者的区别："),e("br"),n._v("\nA首先要走到B的面前，到B的面前之后，A对B说“Hello”，A说完之后B对A说“Hello”，注意这里的每个动作之前都有一段的延迟时间"),e("br"),n._v("\n这个场景如果用callback的方式来描述的话，会是这样：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('A.walkto(function (  )\n    A.say(function (  )\n        B.say("Hello")\n    end,"Hello")\nend, B)\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br")])]),e("p",[n._v("这边只用到2层嵌套，如果再多几层的话，真是非人类代码了，如果用协程来实现：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('co = coroutine.create(function (  )\n    local current = coroutine.running\n    A.walto(function (  )\n        coroutine.resume(current)\n    end, B)\n    coroutine.yield()\n    A.say(function (  )\n        coroutine.resume(current)\n    end, "hello")\n    coroutine.yield()\n    B.say("hello"）\nend)\n\ncoroutine.resume(co)\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br")])]),e("p",[n._v("结构清晰了不少，协程让编程者以同步的方式写成了异步大代码；"),e("br"),n._v("\n来源网上的一句总结："),e("strong",[n._v("让原来要使用异步+回调方式写的非人类代码,可以用看似同步的方式写出来")])]),n._v(" "),e("p",[n._v("不管是协程还是callback，本质上其实提供的是一种异步无阻塞的编程模式，下面看看java在这种模式下的尝试：")]),n._v(" "),e("p",[e("strong",[n._v("java异步无阻塞的编程模式")]),e("br"),n._v("\njava语言本身没有提供协程的支持，但是一些第三方库提供了支持，比如JVM上早期有kilim以及现在比较成熟的Quasar。但是这里没打算就kilim和quasar框架进行介绍；这里要介绍的是java5中的Future类和java8中的CompletableFuture类。")]),n._v(" "),e("p",[n._v("1.Future使用")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("ExecutorService es = Executors.newFixedThreadPool(10);\nFuture<Integer> f = es.submit(() ->{\n             // 长时间的异步计算\n             // ……\n             // 然后返回结果\n             return 100;\n});\n//while(!f.isDone())\nf.get();\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br")])]),e("p",[n._v("虽然Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。"),e("br"),n._v("\n这种模式暂且叫它"),e("strong",[n._v("伪异步")]),n._v("。其实我们想要的是类似Netty中这种模式：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));\nfuture.addListener(new ChannelFutureListener()\n{\n          @Override\n           public void operationComplete(ChannelFuture future) throws Exception\n           {\n                if (future.isSuccess()) {\n                      // SUCCESS\n                 }\n                 else {\n                      // FAILURE\n                 }\n            }\n});\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br")])]),e("p",[n._v("操作完成时自动调用回调方法，终于在java8中推出了CompletableFuture类")]),n._v(" "),e("p",[n._v("2.CompletableFuture使用"),e("br"),n._v("\nCompletableFuture提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。这里不想介绍更多CompletableFuture的东西，想了解更多"),e("a",{attrs:{href:"http://colobu.com/2016/02/29/Java-CompletableFuture/",target:"_blank",rel:"noopener noreferrer"}},[n._v("CompletableFuture介绍"),e("OutboundLink")],1),n._v("，看一个比较常见的使用场景：")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('CompletableFuture<Integer> future = CompletableFuture.supplyAsync(耗时函数);\nFuture<Integer> f = future.whenComplete((v, e) -> {\n        System.out.println(v);\n        System.out.println(e);\n});\nSystem.out.println("other...");\n')])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br")])]),e("p",[n._v("CompletableFuture真正的实现了异步的编程模式")]),n._v(" "),e("p",[e("strong",[n._v("总结")]),e("br"),n._v("\n为什么协程在Java里一直那么小众，Java里基本上所有的库都是同步阻塞的，很少见到异步无阻塞的。而且得益于J2EE，以及Java上的三大框架(SSH)洗脑，大部分Java程序员都已经习惯了基于线程，线性的完成一个业务逻辑，很难让他们接受一种将逻辑割裂的异步编程模型。")])])}),[],!1,null,null,null);s.default=t.exports}}]);