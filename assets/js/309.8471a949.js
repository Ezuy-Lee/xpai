(window.webpackJsonp=window.webpackJsonp||[]).push([[309],{737:function(e,a,s){"use strict";s.r(a);var n=s(15),t=Object(n.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"问题描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题描述"}},[e._v("#")]),e._v(" 问题描述")]),e._v(" "),s("p",[e._v("最近在使用一个内部的RPC框架时，发现如果使用Object类型，实际类型为BigDecimal的时候，作为传输对象的时候，会出现丢失精度的问题；比如在序列化前为金额1.00，反序列化之后为1.0，本身值可能没有影响，但是在有些强依赖金额的地方，会出现问题；")]),e._v(" "),s("h2",{attrs:{id:"问题分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题分析"}},[e._v("#")]),e._v(" 问题分析")]),e._v(" "),s("p",[e._v("查看源码发现RPC框架默认使用的序列化框架为Jackson，那简单，看一下本地是否可以重现问题；")]),e._v(" "),s("h3",{attrs:{id:"_1-准备数据传输bean"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-准备数据传输bean"}},[e._v("#")]),e._v(" 1.准备数据传输bean")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public class Bean1 {\n \n    private String p1;\n    private BigDecimal p2;\n     \n    ...省略get/set...\n}\n \npublic class Bean2 {\n \n    private String p1;\n    private Object p2;\n     \n    ...省略get/set...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("p",[e._v("为了更好的看出问题，分别准备了2个bean；")]),e._v(" "),s("h3",{attrs:{id:"_2-准备测试类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-准备测试类"}},[e._v("#")]),e._v(" 2.准备测试类")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('public class JKTest {\n \n    public static void main(String[] args) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n \n        Bean1 bean1 = new Bean1("haha1", new BigDecimal("1.00"));\n        Bean2 bean2 = new Bean2("haha2", new BigDecimal("2.00"));\n \n        String bs1 = mapper.writeValueAsString(bean1);\n        String bs2 = mapper.writeValueAsString(bean2);\n \n        System.out.println(bs1);\n        System.out.println(bs2);\n \n        Bean1 b1 = mapper.readValue(bs1, Bean1.class);\n        System.out.println(b1.toString());\n         \n        Bean2 b22 = mapper.readValue(bs2, Bean2.class);\n        System.out.println(b22.toString());\n    }\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br")])]),s("p",[e._v("分别对Bean1和Bean2进行序列化和反序列化操作，然后查看结果；")]),e._v(" "),s("h3",{attrs:{id:"_3-显示结果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-显示结果"}},[e._v("#")]),e._v(" 3.显示结果")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{"p1":"haha1","p2":1.00}\n{"p1":"haha2","p2":2.00}\nBean1 [p1=haha1, p2=1.00]\nBean2 [p1=haha2, p2=2.0]\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("h3",{attrs:{id:"_4-结果分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-结果分析"}},[e._v("#")]),e._v(" 4.结果分析")]),e._v(" "),s("p",[e._v("结果可以发现两个问题："),s("br"),e._v("\n1.在序列化的时候2个bean都没有问题；"),s("br"),e._v("\n2.重现了问题，Bean2在反序列化时，p2出现了精度丢失的问题；")]),e._v(" "),s("h3",{attrs:{id:"_5-源码分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-源码分析"}},[e._v("#")]),e._v(" 5.源码分析")]),e._v(" "),s("p",[e._v("通过一步一步查看Jackson源码，最终定位到UntypedObjectDeserializer的Vanilla内部类中，反序列方法如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            switch (p.getCurrentTokenId()) {\n            case JsonTokenId.ID_START_OBJECT:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_OBJECT) {\n                        return new LinkedHashMap<String,Object>(2);\n                    }\n                }\n            case JsonTokenId.ID_FIELD_NAME:\n                return mapObject(p, ctxt);\n            case JsonTokenId.ID_START_ARRAY:\n                {\n                    JsonToken t = p.nextToken();\n                    if (t == JsonToken.END_ARRAY) { // and empty one too\n                        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                            return NO_OBJECTS;\n                        }\n                        return new ArrayList<Object>(2);\n                    }\n                }\n                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                    return mapArrayToArray(p, ctxt);\n                }\n                return mapArray(p, ctxt);\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                return p.getEmbeddedObject();\n            case JsonTokenId.ID_STRING:\n                return p.getText();\n \n            case JsonTokenId.ID_NUMBER_INT:\n                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                    return _coerceIntegral(p, ctxt);\n                }\n                return p.getNumberValue(); // should be optimal, whatever it is\n \n            case JsonTokenId.ID_NUMBER_FLOAT:\n                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                    return p.getDecimalValue();\n                }\n                return p.getNumberValue();\n \n            case JsonTokenId.ID_TRUE:\n                return Boolean.TRUE;\n            case JsonTokenId.ID_FALSE:\n                return Boolean.FALSE;\n \n            case JsonTokenId.ID_END_OBJECT:\n                // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n                //    if caller has advanced to the first token of Object, but for empty Object\n                return new LinkedHashMap<String,Object>(2);\n \n            case JsonTokenId.ID_NULL: // 08-Nov-2016, tatu: yes, occurs\n                return null;\n \n            //case JsonTokenId.ID_END_ARRAY: // invalid\n            default:\n            }\n            return ctxt.handleUnexpectedToken(Object.class, p);\n        }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br"),s("span",{staticClass:"line-number"},[e._v("54")]),s("br"),s("span",{staticClass:"line-number"},[e._v("55")]),s("br"),s("span",{staticClass:"line-number"},[e._v("56")]),s("br"),s("span",{staticClass:"line-number"},[e._v("57")]),s("br"),s("span",{staticClass:"line-number"},[e._v("58")]),s("br"),s("span",{staticClass:"line-number"},[e._v("59")]),s("br"),s("span",{staticClass:"line-number"},[e._v("60")]),s("br"),s("span",{staticClass:"line-number"},[e._v("61")]),s("br")])]),s("p",[e._v("在Bean2中的p2是一个Object类型，所以Jackson中给定的反序列化类为UntypedObjectDeserializer，这个比较容易理解；然后根据具体的数据类型，调用不用的读取方法；因为json这种序列化方式，除了数据，本身并没有存放具体的数据类型，所有这里Jackson认定2.00为一个ID_NUMBER_FLOAT类型，在这个case下面有2个选择，默认是直接调用getNumberValue()方法，这种情况会丢失精度，返回结果为2.0；或者开启使用USE_BIG_DECIMAL_FOR_FLOATS特性，问题解决也很简单，使用此特性即可；")]),e._v(" "),s("h3",{attrs:{id:"_6-使用use-big-decimal-for-floats特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-使用use-big-decimal-for-floats特性"}},[e._v("#")]),e._v(" 6.使用USE_BIG_DECIMAL_FOR_FLOATS特性")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("ObjectMapper mapper = new ObjectMapper();\nmapper.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("再次测试，可以发现结果如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{"p1":"haha1","p2":1.00}\n{"p1":"haha2","p2":2.00}\nBean1 [p1=haha1, p2=1.00]\nBean2 [p1=haha2, p2=2.00]\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("h3",{attrs:{id:"_7-反序列扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-反序列扩展"}},[e._v("#")]),e._v(" 7.反序列扩展")]),e._v(" "),s("p",[e._v("Jackson本身提供了对序列化和反序列扩展的功能，对应特殊的Bean可以自己定义反序列类，比如针对Bean2，可以实现Bean2Deserializer，然后在ObjectMapper进行注册")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('ObjectMapper mapper = new ObjectMapper();\nSimpleModule desModule = new SimpleModule("testModule");\ndesModule.addDeserializer(Bean2.class, new Bean2Deserializer(Bean2.class));\nmapper.registerModule(desModule);\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("h2",{attrs:{id:"扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#扩展"}},[e._v("#")]),e._v(" 扩展")]),e._v(" "),s("p",[e._v("Json本身并没有存放数据类型，只有数据本身，那应该类Json的序列化方式应该都存在此问题；")]),e._v(" "),s("h3",{attrs:{id:"_1-fastjson分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-fastjson分析"}},[e._v("#")]),e._v(" 1.FastJson分析")]),e._v(" "),s("p",[e._v("准备测试代码如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('public class FJTest {\n \n    public static void main(String[] args) {\n        Bean1 bean1 = new Bean1("haha1", new BigDecimal("1.00"));\n        Bean2 bean2 = new Bean2("haha2", new BigDecimal("2.00"));\n \n        String jsonString1 = JSON.toJSONString(bean1);\n        String jsonString2 = JSON.toJSONString(bean2);\n \n        System.out.println(jsonString1);\n        System.out.println(jsonString2);\n \n        Bean1 bean11 = JSON.parseObject(jsonString1, Bean1.class);\n        Bean2 bean22 = JSON.parseObject(jsonString2, Bean2.class);\n \n        System.out.println(bean11.toString());\n        System.out.println(bean22.toString());\n \n    }\n \n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br")])]),s("p",[e._v("结果如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{"p1":"haha1","p2":1.00}{"p1":"haha2","p2":2.00}Bean1 [p1=haha1, p2=1.00]Bean2 [p1=haha2, p2=2.00]\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("可以发现FastJson并不存在此问题，查看源码，定位到DefaultJSONParser的parse方法，部分代码如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public Object parse(Object fieldName) {        final JSONLexer lexer = this.lexer;        switch (lexer.token()) {            case SET:                lexer.nextToken();                HashSet<Object> set = new HashSet<Object>();                parseArray(set, fieldName);                return set;            case TREE_SET:                lexer.nextToken();                TreeSet<Object> treeSet = new TreeSet<Object>();                parseArray(treeSet, fieldName);                return treeSet;            case LBRACKET:                JSONArray array = new JSONArray();                parseArray(array, fieldName);                if (lexer.isEnabled(Feature.UseObjectArray)) {                    return array.toArray();                }                return array;            case LBRACE:                JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField));                return parseObject(object, fieldName);            case LITERAL_INT:                Number intValue = lexer.integerValue();                lexer.nextToken();                return intValue;            case LITERAL_FLOAT:                Object value = lexer.decimalValue(lexer.isEnabled(Feature.UseBigDecimal));                lexer.nextToken();                return value;            case LITERAL_STRING:                String stringLiteral = lexer.stringVal();                lexer.nextToken(JSONToken.COMMA);                 if (lexer.isEnabled(Feature.AllowISO8601DateFormat)) {                    JSONScanner iso8601Lexer = new JSONScanner(stringLiteral);                    try {                        if (iso8601Lexer.scanISO8601DateIfMatch()) {                            return iso8601Lexer.getCalendar().getTime();                        }                    } finally {                        iso8601Lexer.close();                    }                }                 return stringLiteral;            case NULL:                lexer.nextToken();                return null;            case UNDEFINED:                lexer.nextToken();                return null;            case TRUE:                lexer.nextToken();                return Boolean.TRUE;            case FALSE:                lexer.nextToken();                return Boolean.FALSE;            ...省略...}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("类似jackson的方式，根据不同的类型做不同的数据处理，同样2.00也被认为是float类型，同样需要检测是否开启Feature.UseBigDecimal特性，只不过FastJson默认开启了此功能；")]),e._v(" "),s("h3",{attrs:{id:"_2-protostuff分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-protostuff分析"}},[e._v("#")]),e._v(" 2.Protostuff分析")]),e._v(" "),s("p",[e._v("下面再来看一个非Json类序列化方式，看protostuff是如果处理此种问题的；"),s("br"),e._v("\n准备测试代码如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('@SuppressWarnings("unchecked")public class PBTest {     public static void main(String[] args) {        Bean1 bean1 = new Bean1("haha1", new BigDecimal("1.00"));        Bean2 bean2 = new Bean2("haha2", new BigDecimal("2.00"));         LinkedBuffer buffer1 = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);        Schema schema1 = RuntimeSchema.createFrom(bean1.getClass());        byte[] bytes1 = ProtostuffIOUtil.toByteArray(bean1, schema1, buffer1);         Bean1 bean11 = new Bean1();        ProtostuffIOUtil.mergeFrom(bytes1, bean11, schema1);        System.out.println(bean11.toString());         LinkedBuffer buffer2 = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);        Schema schema2 = RuntimeSchema.createFrom(bean2.getClass());        byte[] bytes2 = ProtostuffIOUtil.toByteArray(bean2, schema2, buffer2);         Bean2 bean22 = new Bean2();        ProtostuffIOUtil.mergeFrom(bytes2, bean22, schema2);        System.out.println(bean22.toString());     }}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("结果如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Bean1 [p1=haha1, p2=1.00]Bean2 [p1=haha2, p2=2.00]\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("可以发现Protostuff也不存在此问题，原因是因为Protostuff在序列化的时候就将类型等信息存放在二进制中，不同的类型给定了不同的标识，RuntimeFieldFactory列出了所有标识：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public abstract class RuntimeFieldFactory<V> implements Delegate<V>{     static final int ID_BOOL = 1, ID_BYTE = 2, ID_CHAR = 3, ID_SHORT = 4,            ID_INT32 = 5, ID_INT64 = 6, ID_FLOAT = 7,            ID_DOUBLE = 8,            ID_STRING = 9,            ID_BYTES = 10,            ID_BYTE_ARRAY = 11,            ID_BIGDECIMAL = 12,            ID_BIGINTEGER = 13,            ID_DATE = 14,            ID_ARRAY = 15, // 1-15 is encoded as 1 byte on protobuf and            // protostuff format            ID_OBJECT = 16, ID_ARRAY_MAPPED = 17, ID_CLASS = 18,            ID_CLASS_MAPPED = 19, ID_CLASS_ARRAY = 20,            ID_CLASS_ARRAY_MAPPED = 21,             ID_ENUM_SET = 22, ID_ENUM_MAP = 23, ID_ENUM = 24,            ID_COLLECTION = 25, ID_MAP = 26,             ID_POLYMORPHIC_COLLECTION = 28, ID_POLYMORPHIC_MAP = 29,            ID_DELEGATE = 30,             ID_ARRAY_DELEGATE = 32, ID_ARRAY_SCALAR = 33, ID_ARRAY_ENUM = 34,            ID_ARRAY_POJO = 35,             ID_THROWABLE = 52,             // pojo fields limited to 126 if not explicitly using @Tag            // annotations            ID_POJO = 127;            ......}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("序列化的时候是已如下格式来存储数据的，如下图所示："),s("br"),e._v(" "),s("img",{attrs:{src:"https://oscimg.oschina.net/oscnet/37a30207e0cc900b84001ad9d91a5365b2f.jpg",alt:""}})]),e._v(" "),s("p",[e._v("tag里面包含了字段的位置标识，比如第一个字段，第二个字段…，以及类型信息，可以看一下两个bean序列化之后的二进制信息：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("10 5 104 97 104 97 49 18 4 49 46 48 4810 5 104 97 104 97 50 19 98 4 50 46 48 48 20\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("104 97 104 97 49和104 97 104 97 50分别是：haha1和haha2；49 46 48 48和50 46 48 48分别是1.00和2.00；"),s("br"),e._v("\nBean2存储的数据量明细比Bean1大，因为Bean2中的p2作为Object存储，需要存储Object的起始标识和结束标识，还需要保存具体的类型信息；")]),e._v(" "),s("p",[e._v("更多可以参考："),s("a",{attrs:{href:"https://my.oschina.net/OutOfMemory/blog/800226",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://my.oschina.net/OutOfM..."),s("OutboundLink")],1)]),e._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),s("p",[e._v("类Json序列化方式本身没有保存数据的类型，所以在反序列时有些类型不能区分，只能通过设置特性的方式来解决，但是json格式有更好的可读性；直接序列化为二进制的方式可读性差点，但是可以将很多信息保存进去，更加完善；")])])}),[],!1,null,null,null);a.default=t.exports}}]);