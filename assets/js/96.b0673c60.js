(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{522:function(e,n,a){"use strict";a.r(n);var t=a(15),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("在这个互联网飞速发展的时代，人们已经离不开网络，其中网购最为常见。在家网购，上班路上网购，吃饭也购物，下班还网购，2017年双十一天猫支付峰值达到了25.6万笔/秒。热点网站中频繁出现的大量并发如何去解决？")])]),e._v(" "),a("h2",{attrs:{id:"nginx介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx介绍"}},[e._v("#")]),e._v(" Nginx介绍")]),e._v(" "),a("p",[e._v('Nginx ("engine x") 是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器 。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的Rambler.ru 站点开发的，它已经在该站点运行超过四年多了。Igor 将源代码以类BSD许可证的形式发布。自Nginx 发布以来，Nginx 已经因为它的稳定性、丰富的功能集、 示例配置文件和低系统资源的消耗而闻名了。目前国内各大门户网站已经部署了Nginx，如新浪、网易、腾讯。')]),e._v(" "),a("h2",{attrs:{id:"nginx下载和安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx下载和安装"}},[e._v("#")]),e._v(" Nginx下载和安装")]),e._v(" "),a("p",[e._v("Nginx官网http://nginx.org/")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/zF2qMn7.png",alt:""}})]),e._v(" "),a("p",[e._v("Nginx目前已经更新到了1.13.10版本，我们可以直接到官网下载，由于外面服务器大多都使用linux环境作为服务器，所以我们也弄一台linux环境的虚拟机。")]),e._v(" "),a("p",[e._v("虚拟机我们已经装好了，IP：192.168.211.129，由于nginx是用C语言写的,而且还支持地址栏重写等功能，所以我们需要安装一下相关的依赖包。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("yum install gcc-c++\nyum install -y pcre pcre-devel\nyum install -y zlib zlib-devel\nyum install -y openssl openssl-devel\n")])])]),a("p",[e._v("安装流程如下：")]),e._v(" "),a("ol",[a("li",[e._v("我们把刚才从官网下载的Nginx，文件上传到centos的/usr/local/server目录去。")]),e._v(" "),a("li",[e._v("紧接着我们在server目录下创建nginx目录 把压缩文件解压，进入解压的文件夹。")]),e._v(" "),a("li",[e._v("首先配置nginx安装信息./configure")]),e._v(" "),a("li",[e._v("执行编译和安装make && make install")])]),e._v(" "),a("p",[e._v("安装流程如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("nginx-1.13.10.tar.gz\n[root@localhost server]# tar -xf nginx-1.13.10.tar.gz\n[root@localhost server]# mkdir nginx\n[root@localhost server]# cd nginx-1.13.10\n[root@localhost nginx-1.13.10]# ./configure --prefix=/usr/local/server/nginx\n[root@localhost nginx-1.13.10]# make && make install\n")])])]),a("p",[e._v("上面./configure后面的一些常用参数配置参考如下")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("–prefix\n指定部署根目录，默认是/usr/local/nginx.此设置会更改其他配置目录的相对路径\n–sbin-path\n可执行文件的路径，默认为/sbin/nginx\n–conf-path\n配置文件的路径，默认为/conf/nginx.conf\n–pid-path\npid文件的存放路径，默认存放在/logs/nginx.pid，是一个存放nginx的master进程ID的纯文本文件，刚安装的时候不会生成，nginx启动的时候会自动生成。\n–http-log-path\naccess日志存放位置，每个http的请求在结束的时候都会访问的日志。\n–with-ld-opt\n加入第三方链接时需要的参数。编译之后nginx最终的可执行二进制文件是由编译后的目标文件和一些第三方的库链接生成的。如果想要将某个库链接到nginx中，就需要指定–with-ld-opt=目标库名-目标库路径\n–with-debug\n将nginx需要打印debug调试级别日志的代码编译进nginx，这样才可以通过修改配置文件将调试日志打印出来，便于定位服务问题 \n")])])]),a("p",[e._v("安装第三方模块")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v(" ./configure --prefix=/usr/local/server/nginx --add-module=/usr/local/server/nginx_module/echo-nginx-module-0.61 --with-debug\n")])])]),a("p",[e._v("这时候Nginx已经安全完成，我们进入/usr/local/server/nginx目录查看")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("[root@localhost nginx-1.13.10]# cd ../nginx\n[root@localhost nginx]# ls\nconf  html  logs  sbin\n[root@localhost nginx]# \n")])])]),a("p",[e._v("Nginx安装完成后不要忘了防火墙开放80端口")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("[root@localhost sbin]# vi /etc/sysconfig/iptables\n# Firewall configuration written by system-config-firewall\n# Manual customization of this file is not recommended.\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n-A INPUT -p icmp -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT\n-A INPUT -j REJECT --reject-with icmp-host-prohibited\n-A FORWARD -j REJECT --reject-with icmp-host-prohibited\nCOMMIT\n[root@localhost sbin]# service iptables restart\niptables: Setting chains to policy ACCEPT: filter          [  OK  ]\niptables: Flushing firewall rules:                         [  OK  ]\niptables: Unloading modules:                               [  OK  ]\niptables: Applying firewall rules:                         [  OK  ]\n[root@localhost sbin]# \n")])])]),a("p",[e._v("访问http://192.168.211.129")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/8RdTpwI.png",alt:""}})]),e._v(" "),a("h2",{attrs:{id:"nginx常用命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx常用命令"}},[e._v("#")]),e._v(" Nginx常用命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("nginx常用命令  \n\tnginx -c /usr/local/server/nginx/conf/nginx.conf  启动nginx(windows下start nginx);  \n\tnginx -s quit   停止ngix  \n\tnginx -s reload 重新载入nginx(当配置信息发生修改时)  \n\tnginx -v 查看版本  \n\tnginx -t 查看nginx的配置文件的目录  \n\tnginx -h 查看帮助信息  \n")])])]),a("h2",{attrs:{id:"模块介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块介绍"}},[e._v("#")]),e._v(" 模块介绍")]),e._v(" "),a("h3",{attrs:{id:"主模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主模块"}},[e._v("#")]),e._v(" 主模块")]),e._v(" "),a("p",[e._v("####基本指令 ####")]),e._v(" "),a("h5",{attrs:{id:"daemon"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#daemon"}},[e._v("#")]),e._v(" daemon")]),e._v(" "),a("p",[e._v("语法：daemon on | off"),a("br"),e._v("\n默认值：on"),a("br"),e._v("\n是否以守护进程的方式运行nginx，守护进程是指脱离终端并且在后头运行的进程，关闭守护进程执行的方式可以让我们方便调试nginx")]),e._v(" "),a("h5",{attrs:{id:"master-process"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#master-process"}},[e._v("#")]),e._v(" master_process")]),e._v(" "),a("p",[e._v("语法：on | of 默认on"),a("br"),e._v("\n是否以master/worker方式进行工作，在实际的环境中 nginx是以一个master进程管理多个worker进程的方式运行的，关闭后 nginx就不会fork出worker子进程来处理请求，而是用master进程自身来处理请求worker_processes number; 默认1，在master/worker运行方式下 worker进程的数目，一般情况下用户要配置与CPU内核数相等的worker进程。")]),e._v(" "),a("h5",{attrs:{id:"error-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#error-log"}},[e._v("#")]),e._v(" error_log")]),e._v(" "),a("p",[e._v("语法：error_log file [ debug | info | notice | warn | error | crit ]")]),e._v(" "),a("h5",{attrs:{id:"include"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#include"}},[e._v("#")]),e._v(" include")]),e._v(" "),a("p",[e._v("语法：include file | *\n默认值：none\n你可以包含一些其他的配置文件来完成你想要的功能。"),a("br"),e._v("\n0.4.4版本以后，include指令已经能够支持文件通配符：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("include vhosts/*.conf;\n")])])]),a("h5",{attrs:{id:"pid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pid"}},[e._v("#")]),e._v(" pid")]),e._v(" "),a("p",[e._v("语法：pid file"),a("br"),e._v("\n默认值：编译时指定"),a("br")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("pid /var/log/nginx.pid;\n")])])]),a("p",[e._v("指定pid文件，可以使用kill命令来发送相关信号，例如你如果想重新读取配置文件，则可以使用：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("kill -HUP `cat /var/log/nginx.pid`\n")])])]),a("h5",{attrs:{id:"user"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#user"}},[e._v("#")]),e._v(" user")]),e._v(" "),a("p",[e._v("语法：user user [group]"),a("br"),e._v("\n默认值：nobody nobody"),a("br"),e._v("\n如果主进程以root运行，Nginx将会调用setuid()/setgid()来设置用户/组，如果没有指定组，那么将使用与用户名相同的组，默认情况下会使用nobody用户与nobody组（或者nogroup），或者在编译时指定的--user=USER和--group=GROUP的值。")]),e._v(" "),a("h4",{attrs:{id:"worker-processes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#worker-processes"}},[e._v("#")]),e._v(" worker_processes")]),e._v(" "),a("p",[e._v("语法：worker_processes number 默认值：1")]),e._v(" "),a("p",[e._v("由于以下几点原因，Nginx可能需要运行不止一个进程\n·使用了SMP（对称多处理技术）。\n·当服务器在磁盘I/O出现瓶颈时为了减少响应时间。\n·当使用select()/poll()限制了每个进程的最大连接数时。\n在事件模块这一章中我们将使用worker_processes和worker_connections来计算理论最大连接数（max_clients）：\nmax_clients = worker_processes * worker_connections")]),e._v(" "),a("h3",{attrs:{id:"nginx处理http的核心功能模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx处理http的核心功能模块"}},[e._v("#")]),e._v(" Nginx处理HTTP的核心功能模块")]),e._v(" "),a("p",[e._v("####基本指令 ####")]),e._v(" "),a("h5",{attrs:{id:"alias"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alias"}},[e._v("#")]),e._v(" alias")]),e._v(" "),a("p",[e._v("语法：alias file-path|directory-path;"),a("br"),e._v("\n默认值：no"),a("br"),e._v("\n使用字段：location\n这个指令指定一个路径使用某个某个，注意它可能类似于root，但是document root没有改变，请求只是使用了别名目录的文件。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("location  /i/ {\n  alias  /spool/w3/images/;\n}\n")])])]),a("p",[e._v('上个例子总，请求"/i/top.gif"将返回这个文件: "/spool/w3/images/top.gif"。\nAlias同样可以用于带正则表达式的location，如：')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("location ~ ^/download/(.*)$ {\n  alias /home/website/files/$1;\n}\n")])])]),a("h5",{attrs:{id:"keepalive-timeout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keepalive-timeout"}},[e._v("#")]),e._v(" keepalive_timeout")]),e._v(" "),a("p",[e._v("语法：keepalive_timeout [ time ] [ time ]"),a("br"),e._v("\n默认值：keepalive_timeout 75"),a("br"),e._v("\n使用字段：http, server, location"),a("br"),e._v("\n参数的第一个值指定了客户端与服务器长连接的超时时间，超过这个时间，服务器将关闭连接。"),a("br"),e._v("\n参数的第二个值（可选）指定了应答头中Keep-Alive: timeout=time的time值，这个值可以使一些浏览器知道什么时候关闭连接，以便服务器不用重复关闭，如果不指定这个参数，nginx不会在应答头中发送Keep-Alive信息。（但这并不是指怎样将一个连接“Keep-Alive”）"),a("br"),e._v("\n参数的这两个值可以不相同"),a("br"),e._v("\n下面列出了一些服务器如何处理包含Keep-Alive的应答头："),a("br"),e._v("\n·MSIE和Opera将Keep-Alive: timeout=N头忽略。"),a("br"),e._v("\n·MSIE保持一个连接大约60-65秒，然后发送一个TCP RST。"),a("br"),e._v("\n·Opera将一直保持一个连接处于活动状态。"),a("br"),e._v("\n·Mozilla将一个连接在N的基础上增加大约1-10秒。\n·Konqueror保持一个连接大约N秒。"),a("br")]),e._v(" "),a("h5",{attrs:{id:"listen"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#listen"}},[e._v("#")]),e._v(" listen")]),e._v(" "),a("p",[e._v("语法(0.7.x)：listen address:port [ default [ backlog=num | rcvbuf=size | sndbuf=size | accept_filter=filter | deferred | bind | ssl ] ]"),a("br"),e._v("\n语法(0.8.x)：listen address:port [ default_server [ backlog=num | rcvbuf=size | sndbuf=size | accept_filter=filter | deferred | bind | ssl ] ]"),a("br"),e._v("\n默认值：listen 80"),a("br"),e._v("\n使用字段：server"),a("br"),e._v("\nlisten指令指定了server{...}字段中可以被访问到的ip地址及端口号，可以只指定一个ip，一个端口，或者一个可解析的服务器名。"),a("br")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("listen 127.0.0.1:8000;\nlisten 127.0.0.1;\nlisten 8000;\nlisten *:8000;\nlisten localhost:8000;\n")])])]),a("h5",{attrs:{id:"location"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#location"}},[e._v("#")]),e._v(" location")]),e._v(" "),a("p",[e._v("语法：location [=|~|~"),a("em",[e._v("|^~|@] /uri/ { ... }"),a("br"),e._v("\n默认值：no"),a("br"),e._v("\n使用字段：server"),a("br"),e._v("\n这个参数根据URI的不同需求来进行配置，可以使用字符串与正则表达式匹配，如果要使用正则表达式，你必须指定下列前缀："),a("br"),e._v("\n1、~")]),e._v(" 不区分大小写。"),a("br"),e._v("\n2、~ 区分大小写。"),a("br")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("location  = / {\n  # 只匹配 / 的查询.\n  [ configuration A ]\n}\nlocation  / {\n  # 匹配任何以 / 开始的查询，但是正则表达式与一些较长的字符串将被首先匹配。\n  [ configuration B ]\n}\nlocation ^~ /images/ {\n  # 匹配任何以 /images/ 开始的查询并且停止搜索，不检查正则表达式。\n  [ configuration C ]\n}\nlocation ~* \\.(gif|jpg|jpeg)$ {\n  # 匹配任何以gif, jpg, or jpeg结尾的文件，但是所有 /images/ 目录的请求将在Configuration C中处理。\n  [ configuration D ]\n}\n")])])]),a("h5",{attrs:{id:"resolver-timeout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#resolver-timeout"}},[e._v("#")]),e._v(" resolver_timeout")]),e._v(" "),a("p",[e._v("语法：resolver_timeout time"),a("br"),e._v("\n默认值：30s"),a("br"),e._v("\n使用字段：http, server, location"),a("br"),e._v("\n解析超时时间。如："),a("br"),e._v("\nresolver_timeout 5s;"),a("br")]),e._v(" "),a("h5",{attrs:{id:"root"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#root"}},[e._v("#")]),e._v(" root")]),e._v(" "),a("p",[e._v("语法：root path"),a("br"),e._v("\n默认值：root html"),a("br"),e._v("\n使用字段：http, server, location ,location中的if字段\n请求到达后的文件根目录。"),a("br"),e._v("\n下例中：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("location  /i/ {\n  root  /spool/w3;\n}\n")])])]),a("p",[e._v('如果请求"/i/top.gif"文件，nginx将转到"/spool/w3/i/top.gif"文件。你可以在参数中使用变量。'),a("br"),e._v('\n注意：在请求中root会添加这个location到它的值后面，即"/i/top.gif"并不会请求"/spool/w3/top.gif"文件，如果要实现上述类似于apache alias的功能，可以使用alias指令。')]),e._v(" "),a("h5",{attrs:{id:"server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[e._v("#")]),e._v(" server")]),e._v(" "),a("p",[e._v("语法：server {...}"),a("br"),e._v("\n默认值：no"),a("br"),e._v("\n使用字段：http"),a("br"),e._v("\nserver字段包含虚拟主机的配置。"),a("br"),e._v("\n没有明确的机制来分开基于域名（请求中的主机头）和基于IP的虚拟主机。"),a("br"),e._v("\n可以通过listen指令来指定必须连接到这个server块的所有地址和端口，并且在server_name指令中可以指定所有的域名。")]),e._v(" "),a("h5",{attrs:{id:"server-name"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#server-name"}},[e._v("#")]),e._v(" server_name")]),e._v(" "),a("p",[e._v("语法：server_name name [... ]"),a("br"),e._v("\n默认值：server_name hostname"),a("br"),e._v("\n使用字段：server"),a("br"),e._v("\n这个指令有两个作用："),a("br"),e._v("\n·将HTTP请求的主机头与在nginx配置文件中的server{...}字段中指定的参数进行匹配，并且找出第一个匹配结果。这就是如何定义虚拟主机的方法，域名遵循下述优先级规则："),a("br"),e._v("\n1、完整匹配的名称。"),a("br"),e._v("\n2、名称开始于一个文件通配符："),a("em",[e._v(".example.com。"),a("br"),e._v("\n3、名称结束于一个文件通配符：www.example.")]),e._v("。"),a("br"),e._v("\n4、使用正则表达式的名称。"),a("br"),e._v("\n如果没有匹配的结果，nginx配置文件将安装以下优先级使用[#server server { ... }]字段："),a("br"),e._v("\n1、listen指令被标记为default的server字段。"),a("br"),e._v("\n2、第一个出现listen（或者默认的listen 80）的server字段。"),a("br"),e._v("\n·如果server_name_in_redirect被设置，这个指令将用于设置HTTP重定向的服务器名。"),a("br"),e._v("\n例："),a("br")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("server {\n  server_name   example.com  www.example.com;\n}\n")])])]),a("p",[e._v("第一个名称为服务器的基本名称，默认名称为机器的hostname。\n当然，可以使用文件通配符：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("server {\n  server_name   example.com  *.example.com  www.example.*;\n}\n")])])]),a("p",[e._v("上述例子中的前两个名称可以合并为一个：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("server {\n  server_name  .example.com;\n}\n")])])]),a("p",[e._v("同样可以使用正则表达式。名称前面加“~”：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("server {\n  server_name   www.example.com   ~^www\\d+\\.example\\.com$;\n}\n")])])]),a("h3",{attrs:{id:"http负载均衡模块-http-upstream"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http负载均衡模块-http-upstream"}},[e._v("#")]),e._v(" HTTP负载均衡模块（HTTP Upstream）")]),e._v(" "),a("h4",{attrs:{id:"摘要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[e._v("#")]),e._v(" 摘要")]),e._v(" "),a("p",[e._v("这个模块为后端的服务器提供简单的负载均衡（轮询（round-robin）和连接IP（client IP））\n如下例：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("upstream backend  {\n  server backend1.example.com weight=5;\n  server backend2.example.com:8080;\n  server unix:/tmp/backend3;\n}\n \nserver {\n  location / {\n    proxy_pass  http://backend;\n  }\n}\n")])])]),a("h4",{attrs:{id:"指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#指令"}},[e._v("#")]),e._v(" 指令")]),e._v(" "),a("h5",{attrs:{id:"ip-hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ip-hash"}},[e._v("#")]),e._v(" ip_hash")]),e._v(" "),a("p",[e._v("语法：ip_hash"),a("br"),e._v("\n默认值：none"),a("br"),e._v("\n使用字段：upstream"),a("br"),e._v("\n这个指令将基于客户端连接的IP地址来分发请求。"),a("br"),e._v("\n哈希的关键字是客户端的C类网络地址，这个功能将保证这个客户端请求总是被转发到一台服务器上，但是如果这台服务器不可用，那么请求将转发到另外的服务器上，这将保证某个客户端有很大概率总是连接到一台服务器。"),a("br"),e._v("\n无法将权重（weight）与ip_hash联合使用来分发连接。如果有某台服务器不可用，你必须标记其为“down”，如下例:"),a("br")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("upstream backend {\n  ip_hash;\n  server   backend1.example.com;\n  server   backend2.example.com;\n  server   backend3.example.com  down;\n  server   backend4.example.com;\n}\n")])])]),a("h5",{attrs:{id:"server-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#server-2"}},[e._v("#")]),e._v(" server")]),e._v(" "),a("p",[e._v("语法：server name [parameters]"),a("br"),e._v("\n默认值：none"),a("br"),e._v("\n使用字段：upstream"),a("br"),e._v("\n指定后端服务器的名称和一些参数，可以使用域名，IP，端口，或者unix socket。如果指定为域名，则首先将其解析为IP。"),a("br"),e._v("\n·weight = NUMBER - 设置服务器权重，默认为1。"),a("br"),e._v("\n·max_fails = NUMBER - 在一定时间内（这个时间在fail_timeout参数中设置）检查这个服务器是否可用时产生的最多失败请求数，默认为1，将其设置为0可以关闭检查，这些错误在proxy_next_upstream或fastcgi_next_upstream（404错误不会使max_fails增加）中定义。"),a("br"),e._v("\n·fail_timeout = TIME - 在这个时间内产生了max_fails所设置大小的失败尝试连接请求后这个服务器可能不可用，同样它指定了服务器不可用的时间（在下一次尝试连接请求发起之前），默认为10秒，fail_timeout与前端响应时间没有直接关系，不过可以使用proxy_connect_timeout和proxy_read_timeout来控制。"),a("br"),e._v("\n·down - 标记服务器处于离线状态，通常和ip_hash一起使用。"),a("br"),e._v("\n·backup - (0.6.7或更高)如果所有的非备份服务器都宕机或繁忙，则使用本服务器（无法和ip_hash指令搭配使用）。"),a("br"),e._v("\n示例配置")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("upstream  backend  {\n  server   backend1.example.comweight=5;\n  server   127.0.0.1:8080  max_fails=3  fail_timeout=30s;\n  server   unix:/tmp/backend3;\n}\n")])])]),a("p",[e._v("注意：如果你只使用一台上游服务器，nginx将设置一个内置变量为1，即max_fails和fail_timeout参数不会被处理。"),a("br"),e._v("\n结果：如果nginx不能连接到上游，请求将丢失。\n解决：使用多台上游服务器。"),a("br")]),e._v(" "),a("h5",{attrs:{id:"upstream"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#upstream"}},[e._v("#")]),e._v(" upstream")]),e._v(" "),a("p",[e._v("语法：upstream name { ... }"),a("br"),e._v("\n默认值：none"),a("br"),e._v("\n使用字段：http"),a("br"),e._v("\n这个字段设置一群服务器，可以将这个字段放在proxy_pass和fastcgi_pass指令中作为一个单独的实体，它们可以可以是监听不同端口的服务器，并且也可以是同时监听TCP和Unix socket的服务器。\n服务器可以指定不同的权重，默认为1。\n示例配置"),a("br")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("upstream backend {\n  server backend1.example.com weight=5;\n  server 127.0.0.1:8080   max_fails=3  fail_timeout=30s;\n  server unix:/tmp/backend3;\n}\n")])])]),a("h3",{attrs:{id:"http访问控制模块-http-access"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http访问控制模块-http-access"}},[e._v("#")]),e._v(" HTTP访问控制模块（HTTP Access）")]),e._v(" "),a("h4",{attrs:{id:"摘要-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#摘要-2"}},[e._v("#")]),e._v(" 摘要")]),e._v(" "),a("p",[e._v("这个模块提供简单的基于主机的访问控制。"),a("br"),e._v("\nngx_http_access_module这个模块可以详细的检查客户端IP，并且按顺序执行第一条匹配的规则。"),a("br"),e._v("\n如下例：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("location / {\n  deny192.168.1.1;\n  allow   192.168.1.0/24;\n  allow   10.1.1.0/16;\n  denyall;\n}\n")])])]),a("p",[e._v("上面的例子中仅允许192.168.1.0/24和10.1.1.0/16网络段访问，但192.168.1.1是个例外。"),a("br"),e._v("\n如果要实施很多复杂的规则，那么最好使用GeoIP module模块。")]),e._v(" "),a("h4",{attrs:{id:"指令-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#指令-2"}},[e._v("#")]),e._v(" 指令")]),e._v(" "),a("h5",{attrs:{id:"allow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#allow"}},[e._v("#")]),e._v(" allow")]),e._v(" "),a("p",[e._v("语法：allow [ address | CIDR | all ]"),a("br"),e._v("\n默认值：no"),a("br"),e._v("\n使用字段：http, server, location, limit_except\n指令指定了允许访问的IP或网络段。")]),e._v(" "),a("h5",{attrs:{id:"deny"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deny"}},[e._v("#")]),e._v(" deny")]),e._v(" "),a("p",[e._v("语法：deny [ address | CIDR | all ]"),a("br"),e._v("\n默认值：no"),a("br"),e._v("\n使用字段：http, server, location, limit_except\n指令指定了拒绝访问的IP或网络段。"),a("br"),e._v("\n·提示和技巧"),a("br"),e._v("\nHttpAccess模块可以和error_page指令搭配使用来重定向一个未经验证的访问请求。"),a("br")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("error_page  403  http://example.com/forbidden.html;\nlocation / {\n  deny192.168.1.1;\n  allow   192.168.1.0/24;\n  allow   10.1.1.0/16;\n  denyall;\n}\n")])])]),a("h2",{attrs:{id:"nginx-tomcat实现集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx-tomcat实现集群"}},[e._v("#")]),e._v(" Nginx+tomcat实现集群")]),e._v(" "),a("p",[e._v("当我们网站并发量高的时候，一台tomcat无法承受大量并发，可以考虑Nginx+Tomcat集群来实现。咱们这就做一个集群演示。")]),e._v(" "),a("h3",{attrs:{id:"配置说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置说明"}},[e._v("#")]),e._v(" 配置说明")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/rMiFftn.jpg",alt:""}})]),e._v(" "),a("p",[e._v("我们这里准备3台tomcat，端口分别是8081、8082、8083，针对同一个域名，每次用Nginx实现不同的转发，分别在每个tomcat的webapps目录下创建ROOT目录，并创建index.html，分别在html的body里标记1/2/3以示区分。")]),e._v(" "),a("h3",{attrs:{id:"nginx搭建图片服务器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx搭建图片服务器"}},[e._v("#")]),e._v(" Nginx搭建图片服务器")]),e._v(" "),a("p",[e._v("针对任何站点，几乎都要访问图片，而一个网页里面几乎有好些张图片，这时候会占据大量tomcat连接，造成大量并发，我们可以通过Nginx配置直接访问硬盘里的图片，绕开tomcat。")]),e._v(" "),a("p",[e._v("我们在D盘创建一个nginx_images/images目录，然后在images目录放入一些图片，再在nginx的nginx.conf配置里配置一个虚拟机来访问。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("server {\n    listen       80;\n    server_name  localhost;\n\n\t#所有带有images访问的路径直接取D盘:/nginx_images目录下查找\n    location / {\n        root D:/nginx_images;\n    }\n }\n")])])]),a("h2",{attrs:{id:"keepalived-nginx-集群解决单点故障"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keepalived-nginx-集群解决单点故障"}},[e._v("#")]),e._v(" keepalived+nginx 集群解决单点故障")]),e._v(" "),a("p",[e._v("再牛逼的软件我们也不能保证它一定不挂，为了防止Nginx挂了导致整个服务无法使用的灾难发生，我们这里可以考虑使用Keepalived+Nginx集群实现高可用。")]),e._v(" "),a("h3",{attrs:{id:"keepalived介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keepalived介绍"}},[e._v("#")]),e._v(" keepalived介绍")]),e._v(" "),a("p",[e._v("Keepalived 是一种高性能的服务器高可用或热备解决方案，Keepalived 可以用来防止服务器单点故障的发生，通过配合 Nginx 可以实现 web 前端服务的高可用。"),a("br"),e._v("\nKeepalived 以 VRRP 协议为实现基础，用 VRRP 协议来实现高可用性(HA)。VRRP(Virtual Router Redundancy Protocol)协议是用于实现路由器冗余的协议，VRRP 协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器 IP(一个或多个)，而在路由器组内部，如果实际拥有这个对外 IP 的路由器如果工作正常的话就是 MASTER，或者是通过算法选举产生，MASTER 实现针对虚拟路由器 IP 的各种网络功能，如 ARP 请求，ICMP，以及数据的转发等；其他设备不拥有该虚拟 IP，状态是 BACKUP，除了接收 MASTER 的VRRP 状态通告信息外，不执行对外的网络功能。当主机失效时，BACKUP 将接管原先 MASTER 的网络功能。"),a("br"),e._v("\nVRRP 协议使用多播数据来传输 VRRP 数据，VRRP 数据使用特殊的虚拟源 MAC 地址发送数据而不是自身网卡的 MAC 地址，VRRP 运行时只有 MASTER 路由器定时发送 VRRP 通告信息，表示 MASTER 工作正常以及虚拟路由器 IP(组)，BACKUP 只接收 VRRP 数据，不发送数据，如果一定时间内没有接收到 MASTER 的通告信息，各 BACKUP 将宣告自己成为 MASTER，发送通告信息，重新进行 MASTER 选举状态。")]),e._v(" "),a("h3",{attrs:{id:"方案介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方案介绍"}},[e._v("#")]),e._v(" 方案介绍")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("\tVIP          |     IP           |       主机名     |      主从\n                 | 192.168.211.129  |       keep129   |     master\n 192.168.211.131 |------------------|-----------------|--------------\n                 | 192.168.211.130  |      keep130    |    backup\n")])])]),a("h3",{attrs:{id:"nginx安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx安装"}},[e._v("#")]),e._v(" Nginx安装")]),e._v(" "),a("p",[e._v("在129和130虚拟机上安装nginx，安装过程参考前面学的Nginx。")]),e._v(" "),a("h3",{attrs:{id:"keepalived安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keepalived安装"}},[e._v("#")]),e._v(" keepalived安装")]),e._v(" "),a("p",[e._v("将文件上传到服务器，然后解压安装")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("# cd /usr/local/server\n# tar -zxvf keepalived-1.2.18.tar.gz\n# cd keepalived-1.2.18\n# ./configure --prefix=/usr/local/server/keepalived\n# make && make install\n")])])]),a("p",[e._v("将 keepalived 安装成 Linux 系统服务"),a("br"),e._v("\n因为没有使用 keepalived 的默认路径安装（默认是/usr/local）,安装完成之后，需要做一些工作复制默认配置文件到默认路径")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("# mkdir /etc/keepalived\n# cp /usr/local/server/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/\n复制 keepalived 服务脚本到默认的地址\n# cp /usr/local/server/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/\n# cp /usr/local/server/keepalived/etc/sysconfig/keepalived /etc/sysconfig/\n# ln -s /usr/local/sbin/keepalived /usr/sbin/\n# ln -s /usr/local/server/keepalived/sbin/keepalived /sbin/\n设置 keepalived 服务开机启动\n# chkconfig keepalived on\n")])])]),a("h3",{attrs:{id:"配置主节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置主节点"}},[e._v("#")]),e._v(" 配置主节点")]),e._v(" "),a("p",[e._v("找到129注解keepalived的配置文件keepalived.conf")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('global_defs {\n   router_id keep129;\n}\n\nvrrp_script chk_nginx {\n script "/etc/keepalived/nginx_check.sh"\n interval 2\n weight -20\n}\n')])])]),a("p",[e._v("​\t\nvrrp_instance VI_1 {\nstate MASTER\ninterface eth0\nvirtual_router_id 129\nmcast_src_ip 192.168.211.129\npriority 100\nnopreempt\nadvert_int 1\nauthentication {\nauth_type PASS\nauth_pass 1111\n}")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    track_script {\n\t chk_nginx\n    }\n    virtual_ipaddress {\n        192.168.211.131\n    }\n}\n")])])]),a("h3",{attrs:{id:"配置从节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置从节点"}},[e._v("#")]),e._v(" 配置从节点")]),e._v(" "),a("p",[e._v("找到130注解keepalived的配置文件keepalived.conf")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('global_defs {\n   router_id keep130\n}\n\nvrrp_script chk_nginx {\n script "/etc/keepalived/nginx_check.sh"\n interval 2\n weight -20\n}\n\nvrrp_instance VI_1 {\n    state BACKUP\n    interface eth2\n    virtual_router_id 130\n    priority 90\n    mcast_src_ip 192.168.211.130\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass 1111\n    }\n    track_script {\n \tchk_nginx\n    }\n    virtual_ipaddress {\n        192.168.211.131\n    }\n}\n')])])]),a("h3",{attrs:{id:"nginx检查脚本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx检查脚本"}},[e._v("#")]),e._v(" Nginx检查脚本")]),e._v(" "),a("p",[e._v("在/etc/keepalived目录下创建nginx_check.sh文件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("#!/bin/bash\nA=`ps -C nginx –no-header |wc -l`\nif [ $A -eq 0 ];then\n    /usr/local/server/nginx/sbin/nginx\n    sleep 2\n    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then\n        killall keepalived\n    fi\nfi\n")])])]),a("h3",{attrs:{id:"配置说明-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置说明-2"}},[e._v("#")]),e._v(" 配置说明")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('global_defs {\n ## keepalived 自带的邮件提醒需要开启 sendmail 服务。建议用独立的监控或第三方 SMTP \n router_id keep130 ## 标识本节点的字条串，通常为 hostname\n}\n## keepalived 会定时执行脚本并对脚本执行的结果进行分析，动态调整 vrrp_instance 的优先级。如果\n脚本执行结果为 0，并且 weight 配置的值大于 0，则优先级相应的增加。如果脚本执行结果非 0，并且 weight\n配置的值小于 0，则优先级相应的减少。其他情况，维持原本配置的优先级，即配置文件中 priority 对应\n的值。\nvrrp_script chk_nginx {\n script "/etc/keepalived/nginx_check.sh" ## 检测 nginx 状态的脚本路径\n interval 2 ## 检测时间间隔\n weight -20 ## 如果条件成立，权重-20\n}\n## 定义虚拟路由，VI_1 为虚拟路由的标示符，自己定义名称\nvrrp_instance VI_1 {\n state MASTER ## 主节点为 MASTER，对应的备份节点为 BACKUP\n interface eth1 ## 绑定虚拟 IP 的网络接口，与本机 IP 地址所在的网络接口相同，我的是 eth1\n virtual_router_id 130 ## 虚拟路由的 ID 号，两个节点设置必须一样，可选 IP 最后一段使用, 相\n同的 VRID 为一个组，他将决定多播的 MAC 地址\n mcast_src_ip 192.168.211.130 ## 本机 IP 地址\n priority 100 ## 节点优先级，值范围 0-254，MASTER 要比 BACKUP 高\nnopreempt ## 优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题\nadvert_int 1 ## 组播信息发送间隔，两个节点设置必须一样，默认 1s\n## 设置验证信息，两个节点必须一致\nauthentication {\n auth_type PASS\n auth_pass 1111 ## 真实生产，按需求对应该过来\n}\n## 将 track_script 块加入 instance 配置块\n track_script {\n chk_nginx ## 执行 Nginx 监控的服务\n}\n## 虚拟 IP 池, 两个节点设置必须一样\n virtual_ipaddress {\n \t192.168.199.131 ## 虚拟 ip，可以定义多个\n }\n}\n')])])]),a("p",[e._v("为并发量高的优质网站量身定制高可用的并发解决方案nginx+keepalived")])])}),[],!1,null,null,null);n.default=r.exports}}]);